{"meta":{"title":"老梁有墨","subtitle":"","description":"","author":"会弹吉他的程序员","url":"https://www.laoliang.ink","root":"/"},"pages":[{"title":"","date":"2021-10-28T08:24:25.009Z","updated":"2021-10-28T08:24:25.009Z","comments":true,"path":"404.html","permalink":"https://www.laoliang.ink/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 🔙 返回首页"},{"title":"","date":"2021-10-28T08:24:25.417Z","updated":"2021-10-28T08:24:25.417Z","comments":true,"path":"book/index.html","permalink":"https://www.laoliang.ink/book/index.html","excerpt":"","text":"下面是关于读书的内容 Coming soon…"},{"title":"","date":"2021-10-28T08:24:25.375Z","updated":"2021-10-28T08:24:25.375Z","comments":true,"path":"about/index.html","permalink":"https://www.laoliang.ink/about/index.html","excerpt":"","text":"下面是关于自己的内容 Coming soon…"},{"title":"分类","date":"2021-10-28T08:24:25.423Z","updated":"2021-10-28T08:24:25.423Z","comments":true,"path":"categories/index.html","permalink":"https://www.laoliang.ink/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-10-28T08:24:25.433Z","updated":"2021-10-28T08:24:25.433Z","comments":true,"path":"tags/index.html","permalink":"https://www.laoliang.ink/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"script元素脚本加载详解","slug":"script-元素脚本加载详解","date":"2021-03-20T13:50:35.000Z","updated":"2021-10-28T08:24:25.336Z","comments":true,"path":"posts/20210320215035/","link":"","permalink":"https://www.laoliang.ink/posts/20210320215035/","excerpt":"","text":"我们知道，将 JavaScript 插入 HTML 的主要方法是使用 &lt;script&gt; 元素。这个元素是由网景公司创造出来，并最早在 Netscape Navigator 2 中实现的。后来，这个元素被正式加入到 HTML 规范。 为了更好地了解 JavaScript 在 HTML 中的加载情况，我们先简单介绍一些基础知识。 &lt;script&gt; 元素有下列 8 个属性： async : 可选。表示应该立即开始下载脚本，但不能组织其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。 charset : 可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。 crossorigin : 可选。配置相关请求 CORS（跨域资源共享）设置。默认不适用 CORS。crossorigin=”anonymous” 配置文件请求不必设置凭据标志。 defer : 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在 IE7 及更早的版本中，对行内脚本也可以指定这个属性。 integrity : 可选。允许比对接收到和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。 language : 废弃。最初用于表示代码块中的脚本语言（如“JavaScript”、“JavaScript 1.2”或“VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。 src : 可选。表示包含要执行的代码的外部文件。 type : 可选。代替 language，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是 text/javascript ，尽管 text/javascript 和 ecmascript 都已经废弃了。JavaScript 文件的 MIME 类型通常是 application/x-javascript ，不过给 type 属性这个值有可能 导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有 application/javascript 和 application/ecmascript 。如果这个是 module ，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。 外部 JavaScript 的加载与解释使用 src 属性解析外部资源时，会向 src 属性指定的路径发送一个 GET 请求，以取得相应资源，假定是一个 JavaScript 文件。这个初始的请求不受浏览器同源策略限制，但返回并执行的 JavaScript 则受限制。当然，这个请求仍然受父页面 HTTP/HTTPS 协议的限制。 默认状态下，浏览器会按照 &lt;script&gt; 在页面中出现的顺序依次解释它们，前提是它们没有使用 defer 和 async 属性。第二个 &lt;script&gt; 元素的代码必须在第一个 &lt;script&gt; 元素的代码解释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。 标签位置过去，所有 &lt;script 元素都被放在页面的 &lt;head&gt; 标签内，如下面的例子所示： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;example11.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;example12.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 这里是页面内容 --&gt;&lt;/body&gt;&lt;/html&gt; 这种做法的主要目的是把外部的 CSS 和 JavaScript 文件都集中放到一起。不过，把所有 JavaScript 文件都放在 &lt;head&gt; 里，也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到 &lt;body&gt; 的起始标签时开始渲染）。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。未解决这个问题，现代 Web 应用程序通常将所有 JavaScript 引用放在 &lt;body&gt; 元素中的页面内容后面，如下面的例子所示： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 这里是页面内容 --&gt; &lt;script src=&quot;example11.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;example12.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样一来，页面会在处理 JavaScript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。 推迟脚本执行（defer）HTML 4.01 为 &lt;script&gt; 元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在 &lt;script&gt; 元素上设置 defer 属性，相当于告诉浏览器立即下载，但延迟执行。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script defer src=&quot;example11.js&quot;&gt;&lt;/script&gt; &lt;script defer src=&quot;example12.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 这里是页面内容 --&gt;&lt;/body&gt;&lt;/html&gt; 虽然这个例子中的 &lt;script&gt; 元素包含在页面的 &lt;head&gt; 中，但它们会在浏览器解析到结束的 &lt;/html&gt; 标签后才会执行。HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者会在 DOMContentLoaded 事件之前执行。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。 异步执行脚本（async）HTML5 为 &lt;script&gt; 元素定义了 async 属性。从改变脚本处理方式上看，async 属性与 defer 类似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 defer 不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行，比如： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script async src=&quot;example11.js&quot;&gt;&lt;/script&gt; &lt;script async src=&quot;example12.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 这里是页面内容 --&gt;&lt;/body&gt;&lt;/html&gt; 在这个例子中，第二个脚本可能先于第一个脚本执行。因此，重点在于它们之间没有依赖关系。给脚本添加 async 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该一步脚本下载和执行后再加载其他脚本。正因为如此，异步脚本不应该在加载期间修改 DOM。 异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之后或之前。 脚本加载时机对比 我们上一张图👆 绿色 parser：指的是 HTML 引擎的解析，解析 HTML 文本的解析器 蓝色 fetch：代表的是获取脚本资源 红色 execution：代表的脚本的执行 默认情况下默认情况下，脚本的加载和解析执行，会中断 HTML 文本的解析。 这是由于，由于 JS 解析引擎 和 浏览器渲染引擎，是互斥的，JS 在解析执行过程中，GUI渲染线程会被挂起（渲染的当前状态会被保存）。当 JS 执行结束后，渲染线程才会继续。 使用 defer 属性时使用 defer 属性，脚本的获取加载过程不会中断 HTML 文本的解析，而是通过异步的方式获取脚本。但是，此时脚本的解析执行，仍然要等到 HTML 文本的解析结束后。 使用 async 属性时使用 async 属性时，与 defer 相似的是，脚本的加载同样是异步的方式，不同的是，脚本的解析执行不依赖 HTML 文档的解析结束，脚本会在加载完成后立即解析执行，且这时候会中断 HTML 文本的解析。 针对 type=”module” 的加载执行上面的基础知识部分提到，使用 type=&quot;module&quot; 标记的 &lt;script&gt; 元素，代码会被当成 ES6 模块。 这时候脚本的加载和执行逻辑默认和 defer 属性标记时的规则是一致的，当遇到 &lt;script&gt; 标签元素时，脚本会从模块入口异步开始加载，过程中可能会分叉去加载引用的其他脚本，最后回到入口模块，整个加载过程不会中断 HTML 文本的解析。而脚本的解析执行则像加了 defer 属性一样，需要等待 HTML 文本解析结束后才能开始。 若 使用 type=&quot;module&quot; 时，同时使用 async 属性，那么脚本的解析执行会在加载完成后立即进行，且解析执行过程会中断 HTML 文本的解析。 总结我们知道 &lt;script&gt; 标签是在网页中使用 JavaScript 的最根本的机制，所以，对这些加载时机和各种属性的理解，对我们将来做性能优化和提升脚本的安全性是非常重要的。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"一种适合小团队的Git协作流程","slug":"一种适合小团队的Git协作流程","date":"2021-03-13T14:37:31.000Z","updated":"2021-10-28T08:24:25.369Z","comments":true,"path":"posts/20210313223731/","link":"","permalink":"https://www.laoliang.ink/posts/20210313223731/","excerpt":"","text":"团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的 否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护 分支介绍 master - 主分支 所有提供给用户使用的正式版本，都在这个主分支上发布 开发者在此分支 不可进行 push 操作 dev - 开发分支 日常开发所使用的分支，开发者完成的阶段性功能模块将首先被合并到此分支 此分支亦是团队内部测试、阶段性工作验证所使用的分支 开发者在此分支 不可进行 push 操作，只能通过 Pull Request 的方式将个人分支合并到此分支 开发过程中，要经常与此分支保持同步 feature/xxx - 特性分支 用于某个功能模块的开发，例如：张三创建了一个 feature/package-manager 分支负责开发包管理器模块 当该功能模块开发任务完成后，通过 Pull Request 的形式进行请求合并，管理员 Code Review 通过后，将该分支合并到 dev 分支；此后，该分支将被删除 一旦完成开发，它们就会被合并进 dev 分支（仅能通过 Pull Request 的方式），然后被删除 此类分支由开发者个人管理和使用， 可以进行 push 操作 开发过程中，此类分支要经常与 dev 分支保持同步 hotfix/xxx - 补丁分支 用于紧急修复 Bug 的分支，可以由 master 或 dev 分支创建 同 feature/xxx 分支一样，一旦修复工作完成，它们就会被合并进 master 或 dev 分支 （仅能通过 Pull Request 的方式），然后就被删除 工作流程12# 开发前克隆 dev 分支到本地git clone -b dev https://github.com/liangpengyv/vue-mvvm.git 第一步：新建分支首先，每次开发新功能，都应该新建一个单独的分支 12345678# 获取 dev 分支最新代码git checkout devgit pull# 新建一个特性分支git branch feature/xxx# 切换到该特性分支，进行开发git checkout feature/xxx 第二部：提交分支分支修改后，就可以提交了 123456# 提交代码git add .git commit# 开发过程中，将本地仓库开发中的特性分支 push 到远程仓库（可选的）git push -u origin feature/xxx git push 的 -u 参数，表示将远程仓库 origin/feature/xxx 与 本地仓库 feature/xxx 建立关联，下一次执行 push 命令，可省略后面的远程仓库名和分支名，直接输入 git push 即可 第三步：与 dev 主干同步分支的开发过程中，要经常与 dev 主干保持同步 12345678# 获取 dev 分支最新代码git checkout devgit pull# 切换回当前开发的特性分支git checkout feature/xxx# 合并 dev 分支到当前分支git merge dev 第四步：发出 Pull Request完成当前特性分支的所有开发任务，进行最后一次 与 dev 主干同步 工作，并提交到远程仓库以后，就可以发出 Pull Request 到 dev 分支，然后请求管理员进行 Code Review ，确认可以合并到 dev 分支 1234567# 最后进行一次步骤三的同步工作# 提交到远程仓库git checkout feature/xxxgit push origin feature/xxx# 在 GitHub 管理界面创建 Pull Request，等待管理员进行 Code Review 第五步：清理无用的分支某个特性分支开发任务全部完成后，应删除它 12345678# 首先，切换回 dev 分支git checkout dev# 先删除远程特性分支git push origin -d feature/xxx# 再删除本地特性分支git branch -d feature/xxx","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"Vue的双向绑定原理及简单实现","slug":"Vue的双向绑定原理及简单实现","date":"2021-03-06T01:45:02.000Z","updated":"2021-10-28T08:24:25.284Z","comments":true,"path":"posts/20210306094502/","link":"","permalink":"https://www.laoliang.ink/posts/20210306094502/","excerpt":"","text":"Vue 数据双向绑定原理Vue 数据双向绑定是通过 数据劫持 结合 发布者-订阅者模式 的方式来实现的。 我们先来看下定义在 Vue 初始化数据上的对象是什么样的 代码： 12345678910new Vue(&#123; data: &#123; obj: &#123; foo: 1, &#125;, &#125;, created() &#123; console.log(this.obj) &#125;,&#125;) 结果： 可以看到属性 foo 有两个对应的 get 和 set 方法，这两个方法是如何出现的呢？这是因为 Vue 通过 Object.defineProperty() 来实现数据劫持的，它可以控制对象属性的一些特有操作，如读写权限、是否可枚举等，这里着重关注 get 和 set 两个函数。（有关 Object.defineProperty() 的更多内容，请点击 👆MDN-Object.defineProperty） 首先，我们使用字面量形式初始化一个对象属性 代码： 12345let book = &#123; name: &#x27;JavaScript高级程序设计&#x27;,&#125;console.log(book.name)console.log(book) 结果： 我们重新使用 Object.defineProperty() 的方式来定义对象属性，并对其 get 和 set 方法进行重写操作 代码： 12345678910111213let book = &#123;&#125;Object.defineProperty(book, &#x27;name&#x27;, &#123; get: () =&gt; &#123; return &#x27;《&#x27; + this.name + &#x27;》&#x27; &#125;, set: (value) =&gt; &#123; this.name = value console.log(&#x27;设置 name 属性值为：&#x27; + value) &#125;,&#125;)book.name = &#x27;JavaScript高级程序设计&#x27;console.log(book.name)console.log(book) 结果： 可以看到，这次打印出来的数据，和通过 Vue 初始化的数据结构比较像了吧，它也有了 get 和 set 函数，这正是 Vue 实现 数据劫持 的实现原理。 MVVM 实现思路分析实现 MVVM 主要包含两个方面： 数据变化更新视图 视图变化更新数据 其中，view 更新 data 只需要通过事件监听即可，重点是 data 更新 view 是如何做到的呢？ 其实，上文 数据劫持 的示例已经给出了答案。通过 Object.defineProperty() 对属性设置一个 set 函数，当数据改变时，set 函数就会被触发，所以我们只需要将更新 view 的方法写到这里，就可以实现 data 更新 view 了。 实现一个监听器 Observer监听器 的作用就是去监听数据的每一个属性，通过上面的例子，我们知道可以用 Object.defineProperty() 方法实现。 当监听到属性值发生变化时，通知 订阅者 Watcher 执行更新函数去更新视图。 这个过程中，会有许多订阅者，所以我们还需要创建一个 订阅器 Dep 来统一管理，订阅器 Dep 有一个容器 subs，负责收集订阅者。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function defineReactive(data, key, value) &#123; // 递归遍历所有子属性 observe(value) let dep = new Dep() Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; if (Dep.target) &#123; dep.addSub(Dep.target) &#125; return value &#125;, set: function reactiveSetter(newValue) &#123; if (value === newValue) &#123; return &#125; value = newValue dep.notify() &#125; &#125;)&#125;function observe(data) &#123; if (!data || typeof data !== &#x27;object&#x27;) &#123; return &#125; Object.keys(data).forEach(key =&gt; &#123; defineReactive(data, key, data[key]) &#125;)&#125;function Dep() &#123; this.subs = []&#125;Dep.prototype = &#123; addSub(sub) &#123; this.subs.push(sub) &#125;, notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125;Dep.target = null 实现一个订阅者 Watcher订阅者 Watcher 的作用主要是接收属性变化的通知，然后去执行视图更新函数。 订阅者 Watcher 初始化时，需要将自己添加到订阅器 Dep 中。我们已经知道在监听器 Observer 的 get 函数中通过订阅器 Dep 执行了添加订阅者 Wather 的操作，所以只需要在 Watcher 初始化时触发 Observer 的 get 函数即可。而要触发 get 函数，只要获取对应的属性值便可触发了，这正是因为我们使用了 Object.defineProperty() 进行数据监听。 123456789101112131415161718192021222324function Watcher(vm, exp, cb) &#123; this.vm = vm this.exp = exp this.cb = cb this.value = this.get()&#125;Watcher.prototype = &#123; update() &#123; const value = this.vm.$data[this.exp] const oldValue = this.value if (value !== oldValue) &#123; this.value = value this.cb(value) &#125; &#125;, get() &#123; Dep.target = this const value = this.vm.$data[this.exp] Dep.target = null return value &#125;&#125; 实现一个解析器 Compile解析器 Compile 的作用主要有两个方面： 解析 DOM 节点，识别出模板指令，替换模板数据 对模板指令的节点添加订阅者，绑定更新函数 为实现这两点功能，我们有如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100function Compile(vm) &#123; this.vm = vm this.el = vm.$el this.fragment = null this.init()&#125;Compile.prototype = &#123; init() &#123; this.fragment = this.nodeToFragment(this.el) this.compileNode(this.fragment) this.el.appendChild(this.fragment) &#125;, nodeToFragment(el) &#123; const fragment = document.createDocumentFragment() let child = el.firstChild while (child) &#123; fragment.appendChild(child) child = el.firstChild &#125; return fragment &#125;, compileNode(fragment) &#123; let childNodes = fragment.childNodes const childNodesArray = [...childNodes] childNodesArray.forEach(node =&gt; &#123; if (this.isElementNode(node)) &#123; this.compile(node) &#125; let reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/ let text = node.textContent if (reg.test(text)) &#123; let prop = reg.exec(text)[1] this.compileText(node, prop) &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; this.compileNode(node) &#125; &#125;) &#125;, compile(node) &#123; let nodeAttrs = node.attributes const nodeAttrsArray = [...nodeAttrs] nodeAttrsArray.forEach(attr =&gt; &#123; let name = attr.name if (this.isDirective(name)) &#123; let value = attr.value if (name === &#x27;v-model&#x27;) &#123; this.compileModel(node, value) &#125; &#125; &#125;) &#125;, compileModel(node, prop) &#123; let val = this.vm.$data[prop] this.updateModel(node, val) new Watcher(this.vm, prop, value =&gt; &#123; this.updateModel(node, value) &#125;) node.addEventListener(&#x27;input&#x27;, event =&gt; &#123; let newValue = event.target.value if (val === newValue) &#123; return &#125; this.vm.$data[prop] = newValue &#125;) &#125;, compileText(node, prop) &#123; let text = this.vm.$data[prop] this.updateView(node, text) new Watcher(this.vm, prop, value =&gt; &#123; this.updateView(node, value) &#125;) &#125;, updateModel(node, value) &#123; node.value = typeof value === &#x27;undefined&#x27; ? &#x27;&#x27; : value &#125;, updateView(node, value) &#123; node.textContent = typeof value === &#x27;undefined&#x27; ? &#x27;&#x27; : value &#125;, isDirective(attr) &#123; return attr.indexOf(&#x27;v-&#x27;) !== -1 &#125;, isElementNode(node) &#123; return node.nodeType === 1 &#125;, isTextNode(node) &#123; return node.nodeType === 3 &#125;,&#125; 这段较长的代码，其核心目的就是实现上面说的 2 点功能。 其中，在解析 DOM 过程中，因为会频繁操作 DOM，所以这里先将其缓存到一个 fragment 中，然后再进行解析，解析编译完成后，再把 fragment 添加到页面中。 这里我们只是简单的实现了差值表达式 &#123;&#123;&#125;&#125; 和 v-model 的识别。 创建 MyVue这里我们创建一个 MyVue 类，来连接 Observer、Watcher、Compile。 1234567891011121314151617181920212223242526function MyVue(options) &#123; this.$el = document.querySelector(options.el) this.$data = options.data this.init()&#125;MyVue.prototype = &#123; init() &#123; this.proxyData(this) observe(this.$data) new Compile(this) &#125;, proxyData(vm) &#123; Object.keys(vm.$data).forEach(key =&gt; &#123; Object.defineProperty(vm, key, &#123; get: function proxyGetter() &#123; return vm.$data[key] &#125;, set: function proxySetter(value) &#123; vm.$data[key] = value &#125; &#125;) &#125;) &#125;&#125; 使用 MyVue 替换 Vue现在，我们使用 MyVue 来替换 Vue 接管我们的视图。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;!-- ... --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input v-model=&#x27;name&#x27;&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- &lt;script src=&quot;vender/vue.js&quot;&gt;&lt;/script&gt; --&gt;&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/compile.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // let app = new Vue(&#123; // el: &#x27;#app&#x27;, // data: &#123; // name: &#x27;JavaScript&#x27;, // &#125; // &#125;) // console.log(app) let myApp = new MyVue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;JavaScript&#x27;, &#125; &#125;) console.log(myApp)&lt;/script&gt;&lt;/html&gt; 到这里，我们便实现了一个简单的数据双向绑定。 完整源码完整源码请点击 👆GitHub-vue-mvvm 查看","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"模拟实现 JavaScript 的 apply call 及 bind 函数","slug":"模拟实现-JavaScript-的-apply-call-及-bind-函数","date":"2020-06-04T02:52:36.000Z","updated":"2021-12-04T05:59:03.525Z","comments":true,"path":"posts/20200604105236/","link":"","permalink":"https://www.laoliang.ink/posts/20200604105236/","excerpt":"","text":"在 JavaScript 中，apply、call 和 bind 方法都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 改变 this 指向我们看下面一段代码： 123456789101112131415161718192021var name = &#x27;GlobalName&#x27;var obj = &#123; name: &#x27;ObjName&#x27;&#125;function getName(arg1, arg2) &#123; console.log(this.name, arg1, arg2) // 函数内部调用 this&#125;// this 指向全局对象getName(1, 2)// 预期输出：GlobalName 1 2// 改变 this 指向为 objgetName.apply(obj, [1, 2])getName.call(obj, 1, 2)getName.bind(obj, 1, 2)()// 预期输出：// ObjName 1 2// ObjName 1 2// ObjName 1 2 通过上面一段代码可以看出，我们可以通过 apply、call 和 bind 方法，改变调用 getName() 函数的 运行时上下文，从而改变运行时函数内部的 this 指向。 三个方法的功能区别Function.prototype.apply()apply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。 Function.prototype.call()call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 注意：call() 方法的作用和 apply() 方法类似，区别就是 call() 方法接受的是 参数列表，而 apply() 方法接受的是 一个参数数组。 Function.prototype.bind()bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 注意：bind() 是返回对应函数，便于稍后调用，apply() 、call() 则是立即调用。 模拟实现 apply、call 及 bind实现 myApply()12345678910111213141516171819202122// 实现 apply 函数Function.prototype.myApply = function (context) &#123; // 判断调用 myApply 的是 function 吗 if (typeof this !== &#x27;function&#x27;) &#123; throw new Error(&#x27;type error&#x27;) &#125; // 获取参数 let args = arguments[1] // 将调用函数设置为对象的方法 context.fn = this // 调用函数 let result = context.fn(...args) // 删除属性 delete context.fn return result&#125;getName.myApply(obj, [1, 2]) // 预期输出：ObjName 1 2 实现 myCall()12345678910111213141516171819202122// 实现 call 函数Function.prototype.myCall = function (context) &#123; // 判断调用 myCall 的是 function 吗 if (typeof this !== &#x27;function&#x27;) &#123; throw new Error(&#x27;type error&#x27;) &#125; // 获取参数 let args = [...arguments].slice(1) // 将调用函数设置为对象的方法 context.fn = this // 调用函数 let result = context.fn(...args) // 删除属性 delete context.fn return result&#125;getName.myCall(obj, 1, 2) // 预期输出：ObjName 1 2 实现 myBind()123456789101112131415161718// 实现 bind 函数Function.prototype.myBind = function (context) &#123; // 判断 myBind 的是 function 吗 if (typeof this !== &#x27;function&#x27;) &#123; throw new Error(&#x27;type error&#x27;) &#125; // 获取参数 let args = [...arguments].slice(1) // 将调用函数暂存 let fn = this return function () &#123; return fn.myApply(context, args) &#125;&#125;getName.myBind(obj, 1, 2)() // 预期输出：ObjName 1 2","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"软件测试的分类","slug":"软件测试的分类","date":"2019-04-08T09:58:29.000Z","updated":"2021-10-28T08:24:25.271Z","comments":true,"path":"posts/20190408175829/","link":"","permalink":"https://www.laoliang.ink/posts/20190408175829/","excerpt":"","text":"按测试阶段分类单元测试 对软件中最小可充实单元进行检查和验证 单元测试的原则 尽可能保证各个测试用例是相互独立的 一般由代码的开发人员来实施，用以检验所开发的代码功能符合自己的设计要求 单元测试的益处 能尽早发现缺陷 有利于重构 简化集成 单元测试一定程度替代文档 用于设计，单元测试体验设计思路，设计本身可以用来验证设计 单元测试的限制 不可能覆盖所有的执行路径，所以不可能保证捕捉到所有路径的错误 每一行代码，一般需要 3-5 行测试代码才能完成单元测试，所以存在投入和产出的一个平衡 单元测试框架 JUnit NUnit PHPUnit CppUnit 集成测试 是在单元测试的基础上，测试在将所有的软件单元按照概要设计规格说明的要求组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求的活动 集成测试的主要实施方案 Big Bang 所有的东西都组装好，然后在进行测试 自顶向下 递增组装软件结构的方法，一般来说从主程序开始，沿控制层逐层向下来集成 自底向上 最常用的集成方法，从程序模块最底层的模块开始，逐层向上组装，并逐层的测试；好处是，针对我们已经集成的测试，不需要再针对上一层编写装模块 核心系统集成 先把核心的部分挑选出来，并对这些部分进行集成测试，在测试通过的基础上，在向外围拓展进行测试 高频集成 同步软件开发过程，每过一段时间，就对软件进行集成测试，常说的持续集成 系统测试 是将经过集成测试的软件，作为计算机系统的一个部分，与系统中其他部分结合起来，在实际运行环境下对计算机系统进行的一系列严格有效的测试，已发现软件潜在的问题，保证系统正常运行 关注点 关注系统本身的使用 关注系统与其他相关系统间的连通 关注系统在不同使用压力下的表现 关注系统在真实使用环境下的表现 验收测试 也称交付测试，针对用户需求、业务流程的正式的测试，确定系统是否满足验收标准，由用户、客户或其他授权机构决定是否接受系统 细分 用户验收测试 - 一般由开发方交付前自己做的测试 运行验收测试 - 从运维层面看系统是否能够正常运行，比如系统上线后备份、容灾 合同和规范验收测试 alpha 测试 - 开发者提供的环境进行的测试，一般由用户来执行 beta 测试 - 完全脱离开发环境，由用户提供的环境进行测试 按测试手段分类 黑盒测试、白盒测试 静态测试、动态测试 手工测试、自动化测试 黑盒测试 着眼于外部结构，不考虑内部逻辑，一般针对于软件外部的界面、可见的功能来测试，一般是从用户的视角通过不同的数据和事件来驱动系统，通过输出结果来进行判断 优点 容易实施，不需要关注内部的实现 更贴近用户的使用角度 缺点 测试覆盖率比较低，一般只能覆盖到代码量的不到 40% 针对黑盒的自动化测试，复用率较低，维护成本较高 黑盒测试主要测试什么 主要（更多）应用于 系统测试 阶段 是否有不正确或遗漏的功能 在接口上，输入是否能正确的接受，能否输出正确的结果 是否有数据结构错误或外部信息（例如数据文件）访问错误 性能上是否能够满足要求 黑盒测试的主要设计方法 等价类划分法 边界值分析法 错误推测法 因果图法 正交实验分析法 状态迁移图法 流程分析法 白盒测试 测试人员对内部结构是非常了解的，又称为结构化测试或透明盒测试； 白盒测试是通过程序的逻辑结构设计测试用例，用逻辑的覆盖率来衡量测试的完整性 主要的逻辑单位 语句 条件 条件组合 分支 路径 优点 迫使测试人员去仔细思考软件的实现，理解原理 可以检测到代码中的每条分支和路径 可以揭示隐藏在代码中的错误 对代码的测试比较彻底 缺点 昂贵 - 因为要做到较高的覆盖率，所以成本高 无法检测代码中遗漏的路径和数据敏感性错误 不能直接验证需求的正确性 白盒测试的主要测试方法 代码检测法 静态结构分析法 静态质量度量法 逻辑覆盖法 基本路径测试法 灰盒测试 介于黑、白盒测试之间的，关注输出对于输入的正确性，同时也关注内部表现 静态测试 静态测试是指 无需执行 被测程序，而是通过评审软件文档或代码，度量程序，度量程序静态复杂度，检查软件是否符合编程标准，借以发现编写的程序的不足之处，减少错误出现的概率 特点就是，程序是不被运行的，直接看我们的文档或者代码，可以人工也可以通过自动化工具来做，通过静态的检查代码或者文档的测试手段 测试方式 互审 - 程序员相互检查相互的代码 走查 - 一个小组集体走查程序或文档 会议 - 召开会议 动态测试 是指通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等 手工测试 由专门的测试人员从用户视角来验证软件是否满足设计要求的行为。更适用针对深度的测试和强调主观判断的测试 常见的：众包测试、探索式测试，都是用手工测试完成的 优点 容易发现缺陷 容易实施 创造性、灵活性 缺点 覆盖量化难 重复测试效率低 不一致性、可靠性低 人力资源依赖 自动化测试 使用单独的测试工具软件控制测试的自动化执行以及对于其和结果进行自动检查 常见的：单元测试、接口测试、性能测试等，都是用自动化测试完成的 优点 高效率、速度快 高复用性 覆盖率容易度量 准确、可靠 不知疲劳 缺点 机械、发现缺陷率低 一次性投入较大 按测试模式分类传统的瀑布模型 最早出现的软件开发模型，每一个阶段都是按顺序的向下，到下一个阶段，就像瀑布下落一样 瀑布模型每一个阶段都是以上一个阶段的输出作为下一个阶段的输入 项目计划 ——&gt; 需求分析 ——&gt; 软件设计 ——&gt; 程序开发 ——&gt; 软件测试 ——&gt; 集成维护 优点 强调需求、设计的作用 前一阶段完成后，只需要关注后续阶段 为项目提供了按阶段划分的检查点，里程碑清晰 文档规范 缺点 难以适应需求的频繁变化 项目周期后段才能看到成果 强制的里程碑、完成时间点 文档工作量大 V 模型 需求分析 ——&gt; 概要设计 ——&gt; 详细设计 ——&gt; 软件编码 -&gt; 验收测试 &lt;—— 系统测试 &lt;—— 集成测试 &lt;—— 单元测试 &lt;- 是瀑布模型的变种，是目前使用最广泛的一种模型，在 V 模型中，明确表明了测试过程的不同级别或者不同阶段，并且描述了这些阶段和开发过程各个阶段的对应关系 局限性是：仅仅把测试过程作为需求分析和编码之后的阶段，所以对于需求分析的测试只有到最后的验收测试才会发现问题 W 模型 也称为 双 V 模型，是对 V 模型的改进模型 增加了软件开发各个阶段同步进行验证和确认的活动，测试时伴随整个开发周期进行，测试的对象也不仅仅是程序，他要对需求和设计都要进行相应的测试，开发和测试是两个并行的流程 W 模型 有利于及时了解项目的测试风险，及早确定应对方案 W 模型 也有其局限性，该模型中，需求、编码、测试仍然是串行的，测试和开发保持着一个线性的关系，只有在上一阶段完成之后才能进入下一阶段 X 模型 针对 V 模型 提出的改进 主要解决交接和频繁集成的周期的问题 敏捷测试 Agile Testing —— 遵循 敏捷宣言 的一种测试实践 敏捷宣言： 个体与交互 重于 过程和工具 可用的软件 重于 完备的文档 客户合作 重于 合同谈判 响应变化 重于 遵循计划 在以上每对比较中，后者并非完全无价值，但我们更看重前者 敏捷测试的特点 强调从客户角度进行测试 重点关注迭代测试新功能，不再强调测试阶段 尽早测试，不间断的测试，具备条件即测试 强调持续反馈 预防缺陷重于发现缺陷 敏捷测试 VS 传统测试 传统测试 敏捷测试 - 测试时质量的最后保护者 - 开发和测试人员是紧密合作，大家都有责任对软件负责 - 严格的变更管理 - 变更是可接受的，拥抱变更 - 预先的计划和细节的准备 - 计划随着进展时常调整 - 重量级文档 - 只需要绝对必要的文档 - 各阶段测试严格的入口和出口标准 - 各迭代之间已经没有明显的入口和出口标准 - 更多在回归测试是进行重量级的自动化测试 - 所有阶段都需要自动测试，每个人都需要做，是项目集成的一部分 - 严格依赖流程执行 - 流程不再需要严格执行 - 测试团队和开发团队是相对独立的 - 团队合作是无缝隙合作的 基于脚本的测试 Script-based Testing Scripted Testing (ST) Exploratory Testing (ET) 基于风险的测试 - RBT Risk-based Testing 一种基于对软件失效的风险评估并以此指导测试计划、设计、执行、结果评价的软件测试类型 哪些是风险？ 质量风险 管理风险 风险级别 = 风险可能性 x 风险严重度 识别风险 风险要素分 = Sum（单项权重 * 得分） 可能性 复杂性 时间压力 高变更率 技能水平 地理分散度 严重程度 使用频率 失效可视性 商业损失 组织负面影响和损害 社会损失和法律责任 基于探索式的测试 - ST 完全抛开测试脚本的测试 它是一种测试风格、思维，而不是一种测试技术 ET 和 ST 使用 Pure Scripted Vague Scripted Fragmentary test cases Charters Roles Freestyle ET ST vs ET ST ET - 系统性强 - 自由灵活 - 容易管理、控制 - 和 ST 是互补的 - 设计在先，执行在后 - 执行和设计（思考）并行 - 主要是验证自己的思路 - 不断和系统交互，带着问题测试 - 可预见性 - 学习的过程 探索式测试的优点 更能激发测试人员的创造性和工作乐趣 增加了发现新的或者较深入 Bug 的可能性 可以在较短时间内找到更多 Bug 以及对 SUT 做出一个快速的评估 有利于更加有效地实施自动化 更加适用于敏捷项目 减少了再简单、繁复上用例的无谓编写时间 探索式测试的缺点 测试管理上有局限性，较难协调和控制 对于 Bug 的重复利用和重现上作用有限 对测试人员的测试技能和业务知识深度依赖较大 只有在 SUT 已完全可用的前提下才更有作用 ET 的生产率很难定义 ET 本身较难进行自动化 执行探索式测试 Know You Mession Learning Session Coverage Session Deep Session Close Session 基于模型的测试 - MBT Model-based testing is software testing in which test cases are derived in whole or in part from a model that describes some (usually functional) aspects of the system under test (SUT). 按测试类型分类功能测试 根据产品特性、操作描述和用户反感，测试一个产品的特性和可操作性为已确定他们满足设计需求 针对的问题 功能错误或遗漏 界面问题 性能错误 数据及访问错误 初始化及终止错误 功能测试工具 QTP winrunner silkTest Rational robot selenium Watir Sikuli 性能测试 衍生出： 负载测试 压力测试 稳定性测试 性能指标 并发用户数 VU 每秒事务数 TPS 系统响应时间 设备性能 性能测试工具 LoadRunner Silkperformer Jmeter WebLoad Apache Bench LoadUI 静态性能评估 开发 Web 应用时，基于一系列 Web 应用页面性能优化的最佳实践对 Web 应用的页面进行静态分析，并给出评估结果的性能分析方法 YSlow - 雅虎 PageSpeed - 谷歌 应用性能管理（APM） Application performance Management，提供对系统的实时监控以实现性能管理、故障管理的解决方案 国内产品举例：听云 安全测试 对软件产品进行测试以确保其符合 产品安全需求 和 质量标准 通常相提并论提到的测试：渗透测试 通过模拟对软件系统的恶意攻击行为来评估系统安全性的一种测试 渗透测试 VS 安全测试 渗透测试 安全测试 攻 防 点 面 易 难 OWASP Open Web Application Security Project OWASP Top 10 Test Guide 安全测试工具 Appscan Webinspect Nessus Nmap MetaSploit WebScarab Fortify W3AF 兼容性测试 软件本身的兼容性 - 向后兼容 不同平台下的兼容性 - 运行在多个平台 软件对运行设备的兼容性 - 32位、64位、手机、电视盒子 软件互操作性 - 软件之间的联动 浏览器内核 Trident 4 - 6 —— IE 6 - 8 ，9，10 Gecko —— FireFox WebKit —— Safari、Chrome presto —— Opera 浏览器兼容性测试工具 BrowserShots Browser Sandbox Google 浏览器兼容测试插件 文档测试 针对软件产品的交付品，配套的文档类部件的测试 如：用户手册、使用说明、用户帮助文档等 文档测试关注要点 完整性 正确性 一致性 易理解性 易浏览性 可靠性测试 软件可靠性 硬件可靠性 易用性测试 易用性测试是指测试用户使用软件时是否感觉方便，能否保证用户使用体验的测试类型 一般针对：用户界面、用户交互、网站布局 本地化测试 针对软件的本地化版本实施的针对性测试 主要测试内容 语言、书写习惯 时区、日期格式、货币 当地风俗、法律法规 政治敏感内容 部署测试 也称为安装测试，主要验证系统部署过程，并确保软件经过安装测试后可以正常使用 主要测试内容 在不同环境下的部署验证 参照部署文档执行，过程的合理、正确性 基础数据 无障碍测试 Accessibility Test 也称为访问性测试 是指软件需要提供便于特殊人群使用的功能，包括视障、听障、老年人、身体残疾用户等，无障碍测试则是针对这部分功能的测试 其他的一些测试类型概念回归测试 软件功能修改后，对软件进行重新测试以确认修改没有引入新的错误或导致其他部分产生错误 回归测试的重心在 关键模块 和 重点功能 组件 软件研发周期中会进行多次回归测试，且尽量实现自动化 Monkey 测试 Monkey 测试，也称搞怪测试 就是用一些随机、稀奇古怪的方式来操作软件，以测试系统的健壮性和稳定性 冒烟测试 来自于硬件板卡验证术语 软件上则用于确认代码中的更改会按照预期运行，且不会破坏整个版本的稳定性 “每日构建”中用冒烟测试来确认合入的代码没有影响主要功能的正常 A/B 测试 多用于互联网行业，通过为页面提供 2个版本给用户使用并记录相关的用户行为数据，来确定优化设计的一种测试方案 A/B 测试实施要点 多个方案并行 每次测试仅改动一个变量 按照某种规则进行优胜劣汰 A/B 测试工具 Google Analytics Content Experiments Visual Website Optimizer","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"Java面试-基础知识笔记","slug":"Java-面试-基础知识笔记","date":"2019-03-11T05:34:21.000Z","updated":"2021-10-28T08:24:25.262Z","comments":true,"path":"posts/20190311133421/","link":"","permalink":"https://www.laoliang.ink/posts/20190311133421/","excerpt":"","text":"Synchronized （Java 关键字） 作用： 能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果。 两个用法对象锁 方法锁：默认锁对象为 this 当前实例对象 同步代码块锁：自己指定锁对象 类锁 synchronized 修饰 静态 的方法 synchronized 指定锁为Class对象 多线程访问同步方法的 7 种情况（面试常考） 两个线程同时访问 一个对象 的同步方法 两个线程访问的是 两个对象 的同步方法 两个线程访问的是 synchronized 的 静态 方法 同时访问 同步 方法与 非同步 方法 访问同一个对象的 不同的 普通同步方法 同时访问 静态 synchronized 和 非静态 synchronized 方法 方法 抛异常 后，会 释放锁 7 种情况总结：3 点核心思想 一个锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应 1、 5 中情况）； 每个实例都对应有自己的一把锁，不同实例之间互不影响；例外：锁对象是 *.class 以及 synchronized 修饰的是 static 方式的时候，所有对象共用一把 类锁 （对应 2、 3、 4、 6 种情况）； 无论是方法正常执行完毕或者方法抛出异常，虚拟机都会帮助我们自动释放锁（对应第 7 种情况） Synchronized 缺陷 对比 Lock 接口、读写锁等 效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程 不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的 无法知道是否成功获取到锁 Synchronized 常见面试问题 使用注意点： 锁对象不能为空 作用域不宜过大，提高效率 避免死锁，比如遇到 A 持锁1要 锁2 的同时 B 持锁2 要锁1 如何选择 Lock 和 Synchronized 关键字？ 有现成的工具包，就用现成的 非要用，优先选用 Synchronized ，减少代码量 RedisRedis 在 Java Web 中的主要应用场景 存储 缓存 用的数据 需要高速读/写的场合 使用它快速读/写 数量控制器 消息队列 消息队列的概念与应用应用场景 冗余：比如数据排队处理并持久化后，删除原数据 解耦：分离两套系统 流量消峰：秒杀抢购 异步通信：队列使请求直接返回，后面慢慢处理 扩展性： 排序保证： 队列介质 MySQL：可靠性高、易于实现、速度慢 Redis：速度快，单条大消息包时候效率低 消息系统（RabbitMQ等）：专业性强、可靠、学习成本高 消息处理触发机制 死循环方式读取：易实现，故障时无法及时恢复 定时任务：压力均分，有处理量上限 守护进程：类似于 PHP-FPM 和 PHP-GG，需要 Shell 基础 数据库设计ER 图例说明 矩形：表示实体集，矩形内写实体集的名字 菱形：表示联系集 椭圆：表示实体的属性 线段：将属性连接到实体集，或将实体集连接到联系集 设计范式 第一范式 定义： 数据库表中的所有字段都是单一属性，不可再分，这个单一属性是由基本的数据类型所构成的 换句话说 ，第一范式要求数据库中的表都是二维表 第二范式 定义： 数据库的表中不存在非关键字段对任一候选关键字段的部分函数依赖 部分函数依赖 是指存在着组合关键字中的某一关键字决定非关键字的情况 换句话说： 所有单关键字段的表都符合第二范式 第三范式 第三范式是在第二范式的基础之上定义的， 如果数据表中不存在非关键字段， 对任意候选关键字段的传递函数依赖， 则符合第三范式 BC 范式（Boyce.Codd 范式） 定义： 在第三范式的基础之上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖，则符合 BC 范式 也就是说，如果是复合关键字，则复合关键字之间也不能存在函数依赖关系 物理设计 选择合适的数据管理系统（Orale、MySQL、PgSQL） 定义数据库、表及字段的命名规范 根据所选的 DBMS 系统选择合适的字段类型（char、vachar） 反范式化设计（如：出于读写效率考量，增加数据冗余） MySQL 常见的存储引擎 存储引擎 事务 锁粒度 主要应用 忌用 MyISAM 不支持 支持并发插入的表级锁 select，insert 读写操作频繁 MRG_MyISAM 不支持 支持并发插入的表级锁 分段归档，数据仓库 全局查找过多的场景 Innodb 支持 支持 MVCC 的行级锁 事务处理 无 Archive 不支持 行级锁 日志记录，只支持insert，select 需要随机读取，更新，删除 Ndb cluster 支持 行级锁 高可用性 大部分应用 操作系统进程与线程区别与联系 进程是系统资源分配的最小单位 线程是程序执行的最小单位 进程使用独立的数据空间 线程共享同一线程的数据空间 线程调度 时间片轮转调度 先来先服务调度 优先级调度 多级反馈队列调度 高响应比优先调度 网络知识TCP协议 建立连接：三次握手 管理连接：四次挥手 报文状态标志与连接状态 Nagel 算法与 ACK 延迟 KeepALive - 是在长时间没有数据发送的情况下保持连接可用的机制，需要了解开启和设置方式 滑动窗口与流量控制 HTTP 协议协议 Method Header Cookies UrlEncode状态码HTTPSHTTP2 多路复用 Stream 流量控制 服务端推送 头部压缩 UDP 非连接 非可靠传输 效率高 QUIC 避免前序包阻塞（HOL阻塞） 零 RTT 建连 FEC 前向纠错 OSI 模型 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 （物联网输会示用） TCP/IP 模型1. 应用层 对应 OSI 的应用层、表示层、会话层 Telnet 协议能提供远程登录服务 FTP（File Transfer Protocol）文件传输协议 SMTP（Simple Mail Transaction Protocol）简单邮件传输协议 SNMP（Simple Network Management Protocol）简单网络管理协议 HTTP（HyperText Transfer Protocol）超文本传输协议 RPC（Remote Procedure Call）远程过程调用 2. 传输层 TCP（Transmission Control Protocol）传输控制协议 UDP（User Datagram Protocol）用户数据包协议 QUIC（Quick UDP Internet Connection）快速 UDP 网络连接 - 基于 UDP 实现原 HTTP 功能，现已被标准化为 HTTP3 协议 3. 网络层 IP（Internet Protocol）网络协议 ICMP（Internet Control Message Protocol）网络控制信息协议 IGMP（Internet Group Management Protocol）网络组群管理协议 4. 网络接口层 对应 OSI 的数据链路层、物理层 ARP（Address Resolution Protocol）地址解析协议 RARP（Reverse Address Resolution Protocol）反向地址转换协议 设计模式创建型工厂方法模式（常用） 在实际业务中经常用到，也是面试的主要考察点，是创建不同类型实例常用的方式 spring 中的 bean 都是有不同工厂类创建的 抽象工程模式单例模式（常用） 线程安全实现的常用三种方法 静态初始化（饿汉），不管是否使用都会创建 双检锁（懒汉），单例变量必须要用 volatile 修饰 单例注册表，spring 中 bean 的单例模式就是用该方法实现 建造者模式 适用于一个对象拥有很多复杂的属性，需要根据不同情况创建不同的具体对象 创建 Protocol Buffer 对象时，需要用到 Builder 原型模式结构型适配器模式（常用） 类似于转接头，将两种不匹配的对象进行适配，也可以起到对两个不同的对象进行解耦的作用 SLF4J 可使项目 Log4、Logback 等具体日志实现框架进行解耦，其通过不同适配器与不同框架进行适配，完成日志功能的使用 装饰器模式代理模式（常用） 在不适合或不能直接引用另一个对象的场景，可以用代理模式对被代理的队形进行访问行为的控制，Java的代理模式分为静态代理和动态代理，静态代理是指在编译时就创建好的代理类，例如在源代码中编写的类，动态代理指在 JVM 运行过程中动态创建的代理类， 如 JDK 动态代理，CDLIB，Javaasist 等 例如：在 MyBatis 中 getMapper 时会通知 MapperProxyFactory 及配置文件动态生成的 Mapper 代理对象，代理对象会拦截 Mapper 接口的方法调用，创建对应方法的 MapperMethod 类并执行 execute 方法，然后返回结果 外观模式桥接模式组合模式享元模式行为型策略模式模板方法模式观察者模式（常用） 也可称为发布订阅模式，适用于一个对象某个行为需要出发一系列操作的场景 GRPC 中 Stream 流式请求的处理 迭代器模式责任链模式（常用） 类似工厂流水线，其中的每个节点完成对对象的某一种处理 Netty 框架的处理消息的 Pipeline 就是采用的责任链模式 命令模式备忘录模式状态模式访问者模式中介者模式解释器模式Java 语言Java 语言特性集合类 主要掌握如何实现 动态代理与反射 是 Java 语言的特色，需要掌握动态代理与反射的使用场景 ORM 框架中会大量使用代理类，RPC 调用时使用反射机制调用实现类的方法 数据类型 也是面试的常见问题，如每种数据类型占用多大空间，数据类型的自动转换与强制转换，基础数据类型与 Wrapper 数据类型的自动装箱与拆箱等 对象引用 （可自行搜索） Java基础常考点 - MapHashMap 通过数组加链表实现 数组中的元素为一个链表，通过计算存入对象的 hashcode，确认存入位置，用链表解决散列冲突，链表的节点存入的是键值对 填充因子的作用 Map 扩容的 rehash 机制 容量是二的幂次方 是为了方便按位与操作计算余数，比求模更快 多线程风险的原因 对线程 put 时，会在超过填充因子的情况下 rehash.HashMap 为避免尾部遍历，链表插入采用头插法，多线程场景下可能产生死循环 ConcurrentHashMap 分段锁思想 1.7 中采用 segment 分段加锁，降低并发锁定程度 CAS 自旋锁 1.8 中采用 CAS 自旋锁（一种乐观锁实现模式）提高性能，但在并发度较高时，性能一般 红黑树 1.8 引入红黑树解决 hash 冲突时的链表查找问题，在链表长度大于 8 且总容量大于 64 时启用，扩容后链表长度小于 6 时重新转为一般链表（8,6,64为默认参数） Java 版本特性1.8 Lambda 表达式 StreamAPI 方法引用 接口默认方法 Metaspace 替换 PremGen 1.9 - 1.10 模块系统 默认 G1 回收器 接口私有方法 局部变量判断 Graal 编译器 1.11 ZGC 字符串 API 增强 内建 HTTP Client 面试考察点基本概念和基本原理 理解正确清晰 网络协议 4/7 层模型的概念 TCP 协议流量控制的实现原理 …… 实现方法和使用方法 HashMap 在 JDK 1.8 中的实现方式 单例模式有哪几种实现方式，什么场景该使用静态方法实现，什么场景该使用双检锁实现 …… 经常用到的知识点 常用的 Linux 命令有哪些，用来解决什么样的问题 …… 实际应用中容易犯错的点 == 与 equals 区别是什么 对象强引用使用不当会导致内存泄露，考察不同引用方式和作用的理解 …… 与面试方向相关的知识点 中间件、存储、网络相关的考察 …… 加分项 知识点与典型的业务场景关联 如：谈到设计模式时，可以讲 XX 框架在解决 XX 问题时使用了那种设计模式 以反例来描述实际场景中误用的危害 如：大量使用反射会影响性能 与知识点相关的优化点 如：讲到 TCP 建连和断连时，如遇到洪水攻击或大量 TIME_WAIT 时，可以调整系统参数预防 与知识点相关的最新技术趋势 如：讲到 ConcurrentHashMap，可以介绍 1.8 的改进细节 或：讲到 HTTP 时，能说出 HTTP2 和 QUIC 的特点和实现 在了解的前提下，尽量增加回答内容的深度 如：讲到 TCP 的滑动窗口时，能讲到流量与拥塞控制，进一步能指出解决拥塞的不同算法 真题汇总1. 进程和线程的区别和联系 从资源占用，切换效率，通信方式等方面回答 2. 简单介绍一下进程的切换过程 线程上下文的切换代价，要回答，切换会保存寄存器、栈等线程相关的现场，需要由用户态切换到内核态，可以用 vmstat 命令查看线程上下文的切换情况 3. 你经常使用哪些 Linux 命令，主要用来解决哪些问题4. 为什么 TCP 建连需要 3 次握手，而断连需要 4 次5. 为什么 TCP 关闭连接时需要 TIME_WAIT 状态，为什么要等 2MSL6. 一次完整的 HTTP 请求过程是怎样的 DNS 解析，TCP 建连，HTTP 请求，HTTP 响应等 7. HTTP2 和 HTTP 的区别有哪些8. 在你的项目中你使用过哪些设计模式，主要用来解决哪些问题9. Object 中的 equals 和 hashcode 的作用分别是什么10. final， finally， finalize 的区别于使用场景11. 简单表述一下 Java 的异常机制12. 线上使用的哪个版本 JDK， 为什么使用这个版本（有什么特色）","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"年轻人何以成为“隐形贫困人口”？","slug":"年轻人何以成为“隐形贫困人口”？","date":"2018-05-03T08:17:55.000Z","updated":"2021-10-28T08:24:25.175Z","comments":true,"path":"posts/20180503161755/","link":"","permalink":"https://www.laoliang.ink/posts/20180503161755/","excerpt":"","text":"长的是磨难，短的是人生，在惘惘莫名的威胁感下，“人们受不了这个，急于攀住一点踏实的东西”，于是“从柴米油盐、肥皂、水与太阳之中去找寻实际的人生” “佛系青年”还言犹在耳，同龄人“抛弃”你也没过多久，“隐形贫困人口”这个词火了。根据网络定义，隐形贫困人口是指“那些看起来每天有吃有喝，但实际上非常穷的人”。 “能买戴森吸尘器就不用扫帚了；吃完牛油果又要吃藜麦了；100块钱一张的‘前男友面膜’用起来也不心疼；一有健身冲动，就非得去办张年卡。总之，朋友圈光鲜靓丽，口袋空空如也，‘吃土’是常态，在精致道路上拿出十八般武艺、拼尽全力。”在“隐形贫困人口”的相关评析文章中，“隐形贫困人口”被认定是“自我消费不节制所造成的”，正是因为想过得富一点，所以把日过得穷了。甚至有人认为，“隐形贫困人口”与之前流行的“月光族”“啃老族”没有太大区别。 不过将年轻人的“贫困”归咎于消费主义和消费的不节制，是否会遮蔽了一些什么？比如许多年轻人“非常穷”，倒不是因为他们将钱花费在吃好喝好上了，而是因为他们真的穷。即便有年轻人将大部分的金钱花在吃好喝好上，仅仅是因为他们热衷消费，还是背后有什么更深层次的原因？比如究竟是热衷消费导致了贫困，还是因为贫困所以热衷消费？ 总之，一个热词背后往往蕴藏着重要的社会心理信息，“隐形贫困人口”的理论景深值得细究。 大众传媒时代的“贫困感”身边一位50后的长辈学者，对现在年轻人老是说自己“贫困”“丧”很是不屑。在他看来，物质生活好了，年轻人都是蜜罐中长大，身在福中不知福，还养了一身矫情的本领。他说，他们那一辈人的成长岁月里，物质短缺、缺衣少食，饥饿是家常便饭，现在年轻人所能享受到的丰富和便捷的物质生活，是他们那个时代的人从来都不敢想的事。怎么现在的80后、90后、00后，动不动就觉得自己那一代人是“最不幸的”？ 长辈的质疑，纵然有代际隔阂的因素，却也提出了一个重要的问题，即怎么物质生活越来越好，自称“贫困”的人却越来越多了？这与其说是这一代年轻人矫情，毋宁说，老一辈与年轻人对于“贫困”的认定和感知是不一样的。在老一辈那里，贫困更多意味着最基本的生存需求无法满足，但在新一代年轻人这里，不贫困不仅仅意味着有吃有喝，还意味着吃好喝好，甚至更多。那么，年轻人的贫困阈值，是如何不断提高的？ 这里不得不着重强调的是，高度发达的大众传媒对年轻人观念的影响。我们已经进入了一个大众传媒时代，传媒榫入日常生活的方方面面，并不断塑造着人们的认知。文化学者南帆指出，“现代社会的标志是我们被抛入了大众传媒组织起来的社会，大众传媒就是我们的文化感官。几张报纸、几个电视频道或者几个网站就布置出了一个大千世界的幻象。”而这个幻象的核心是，种种幸福生活的神话。阿兰·德波顿在《身份的焦虑》一书中写道，“报刊和社会舆论没完没了的鼓噪，让每个生活在底层的人都相信他们总有机会攀上社会金字塔的塔尖，有机会成为实业家、大法官、科学家，甚至是总统。这种无限机遇的论调在一开始也许能给人一种盲目的乐观，对那些底层的年轻人尤甚。” ▲ “受众劳动”，英文Audience Labour，由Smythe在1977年提出，他认为在闲暇时间收看电视、阅读报纸的“受众”实际是为广告商工作，是广告支持下的传播业所生产的一种特殊商品。传统的马克思主义研究没有对传播体系的经济作用给予足够的关注，生产这种学习消费的受众是大众 我们每时每刻都在被成功人士的故事包围，哪个年轻人月薪5万，哪个年轻人创业成功一跃成为亿万富翁；即便是电视里的广告，不断宣扬的也是一种中产阶层的生活样本：一栋别墅，阳光照射进来，漂亮的妻子在做家务，小孩在快乐地玩耍…… 身边的幸福神话太多，其结果就是知名作家韩少功所说的，“每个人都可以找到足够根据，来发现自己的贫困”。跟胡玮炜相比，年薪30万的码农是贫困的；跟北京三环有一套房的人相比，三线城市有一套房的人是贫困的……“人们从现代文化工业那里获取了太多的感受能力及其知识装备，也从文化工业那里接受了太多有关人类幸福的神话，于是特别容易产生自我感觉的模拟演习，直至在心理上自伤”。 也即，许多年轻人自嘲“隐形贫困”，倒不见得他们是真的贫困，他们的“贫困感”有可能是来自于传媒时代的文本感染和广告后遗症，来自于与幸福神话的对照和攀比。“这个社会的传媒技术已经市场化或者权力化，受控于资本化的权力或者权力化的资本”（韩少功语），权力和资本媾和打造幸福神话，才能源源不断激发受众的“贫困感”，激发他们的消费冲动，并让他们心甘情愿成为消费的“顺民”。 从这个角度看，某些人自嘲“隐形贫困人口”，倒真有可能是一种矫情，是不断夸大的心理自伤。 不断壮大的“穷忙族”不过，时代不断进步的标志本来就是，人们对贫困标准的认定在不断提高。以前吃好喝好就是不贫困，但如果几十年过去了，人们的需求依旧停留在马斯洛需求层次的最低阶段，那么这绝对称不上一个好的时代。虽然攀比逻辑值得检讨，但比烂逻辑更是要不得。 应该看到，“隐形贫困人口”的自嘲，固然不乏大众传媒时代滋生的“贫困感”，但更多可能是出于一种贫困实感。这种贫困实感，或来自于生存和发展的需求得不到满足，或来自于安全、尊重以及自我实现的需求得不到满足。比如纵向对比，现在年轻人的物质生活的确比上世纪五六十年代好多了，但与当下时代的生活成本、发展前景等横向比较，这一代年轻人的处境就不见得比老一辈更好。 在“隐形贫困人口”这个词走红之前，另一个与贫困有关的词汇，就长久地成为不少年轻人对自我生存状态的概括，即“穷忙族”（working poor）。该词源于欧美国家，欧盟对其定义是“在工作却入不敷出，甚至沦落到贫穷线以下的受雇者”。按照常理，付出跟收入应该呈正相关，但如今越来越多的年轻人却是越穷越忙，越忙越穷；他们一直在努力工作，生活状态却不见根本性的改善。 ▲ NHK纪录片《穷忙族》。 © 知乎 2017年12月，中山大学社会科学调查中心发布《中国劳动力动态调查：2017年报告》显示，中国劳动力每周工作时间在50或50小时以上的分别为43.90%、42.57%，比例均超过四成。“996”（工作日早9点上班，晚上9点下班，中午和晚上休息1小时甚至更少，并且一周工作6天的工作制度）成为许多年轻人的工作常态，越是大的、节奏快的城市越是如此，他们在办公室的时间甚至比跟家人在一起的时间更多。曾有深受加班困扰的白领说，“如果不是大楼高层的窗户不能打开，很多人都可能已经跳下去了。” 但不少年轻人努力付出，他们却变得“越来越穷”，他们的收入增速远低于国民收入的增速。腾讯·今日话题在一篇文章中指出，对比应届毕业生平均薪资增速和居民人均可支配收入增速可发现，在2012-2015年，刚毕业大学生工资的整体增速赶不上社会平均水平。在很大程度上，毕业生就是年轻人的代表。不去考虑大学毕业生起薪低的问题，这个群体的工资增速没有和社会整体同步，年轻人存在“相对贫困”的问题，他们正成为“失落的阶层”。 除了工作强度大、工资低，更令年轻人困扰和焦虑的，还在于他们未来前景的“不稳定”，即便他们勤勤恳恳地工作，也随时可能有失业的风险。土逗公社在一篇文章中，讨论了Alex Foti在《“不稳定无产者”的一般性理论》（General Theory of thePrecariat）一书中提出的“不稳定的无产者”（Precariat）这一概念。Precariat来自于precarious（不稳定的）和proletariat（无产阶级）两个词的组合，它指涉的是处于不稳定雇佣关系中的无产者：低工资、缺乏劳动保护、没有社会保障、随时需要工作也随时可能被解雇；而90后、00后正在成为precariat中最重要的部分。 一边是“穷忙族”的生活和工作状态，一边是高不可攀的房价、高昂的生活成本、看不到预期的未来——许多年轻人何止是“隐形贫困人口”，他们是实实在在的贫困。 用消费来安慰苦难的人生矛盾的地方就在于，如果很多年轻人是真的贫困，可他们为何如此热衷于消费主义？不少社会学家都留意到这样一个现象，月收入不高的流水线年轻工人，所使用的手机常常是价格最为昂贵的iphone系列。究竟是消费导致他们沦为贫困，还是因为贫困所以他们更热衷于消费？ 按照文化学者王晓明先生的分析，今天的中国人“同时受制于三个社会系统”：“第一个是国家机器主导的政治系统，它以‘维稳’为宗旨，竭力加固那种‘除了适应现实，我们别无选择’普遍意识。第二个是中国特色的市场经济系统，它通过各种具体的成文和不成文法，持续训练人接受这样的自我定位，‘现代人，就是如下两面的结合：合乎市场需求的劳动力，和具有不可控制的消费冲动的消费者’。第三个日常生活系统，它安排人以‘居家’为中心，组织自己的大部分人生内容，从儿童时代接受学校教育开始，一直到老。这个系统持续地发展一种具有极宽的包含力的‘居家文化’，对人潜移默化，要将他造得除了‘居家’的舒适，别的什么都不在意。” ▲ 近年来，消费金额持续上涨，形成消费升级的浪潮。 © 国务院 埃里克·霍弗在《狂热分子》中也分析道，“当我们的生活朝不保夕，完全无力控制我们的生存环境时，就会执着于熟悉的生活方式。我们通过把生活模式固定化去对抗深深的不安全感。借此我们给自己制造了一种幻象：不可预测性已为我们所驯服。”也即，在艰难的生存现实面前，中国年轻人只能愈发投入于可预测、可掌控的消费与居家文化中，对日常生活系统的消费和呵护成为一种潮流。 这颇像张爱玲说的，长的是磨难，短的是人生，在惘惘莫名的威胁感下，“人们受不了这个，急于攀住一点踏实的东西”，于是“从柴米油盐、肥皂、水与太阳之中去找寻实际的人生”。年轻人买不起房子，却买得起一些让自己感受更好的居家用品，诚如学者严锋分析的，“人是渴望改变的，生活是很难改变的，生活中只有电子产品最容易改变，所以只能从电子产品的更新中获得一种虚幻的改变感，安慰苦难的人生。” 因此，不少对“隐形贫困人口”的批评颠倒了因果，并非“月光族”让年轻人贫困，而是因为贫困，年轻人只剩下哈维尔所说的那种“自由地选择哪一种牌子的冰箱和洗衣机”的自由了。 哈维尔深刻地指出，这种只热衷于消费主义的倾向会加剧公众的政治冷漠，贫困的状态将更难改变。“一个人越是彻底放弃任何全面转变的希望，放弃任何超越个人的目标和价值，或任何对一种‘外在’（即指公共事务，笔者注）方面发挥影响的机会，他的能量就转向阻力最小的方面，即‘内在’（指私人的物质生活，笔者注）。今天的人们一心一意地想着自己的家庭和房子，他们在那儿找到安息，忘掉世界的愚蠢……”“通过将每一个人的注意力集中在他仅仅是消费品的兴趣上，是希望使他没有能力意识到在他精神上、政治上、道德上日益增长的被侵犯的程度。将他缩减成一个初级消费品社会的各种观念的简单容器，是打算将他变成复杂操纵的顺从的材料。” 这或许才是“隐形贫困人口”背后的消费主义倾向值得我们高度警惕的地方。以消费安慰困难的人生，获取一点虚幻的改变感，是个人权利，也无可厚非；但我们切勿在权力和资本的鼓动下，全情投入到消费主义的怀抱中，尝到一点消费主义的甜头后，便心甘情愿地忍受贫困和剥削。要打破贫困，根本上应该打破“除了适应现实，我们别无选择”的政治意识，走出政治冷漠，积极参与每一次公共事务，积极维护个人的权益不受侵犯。 这很难，但想改变被剥夺和不公制造的贫困状态，就得从现在做起。 ——首发南都观察—— 版权归作者所有，任何形式转载请联系作者。作者：曾于里（来自豆瓣）来源：https://www.douban.com/note/667467299/","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"多元思维模型","slug":"多元思维模型","date":"2017-10-23T10:45:59.000Z","updated":"2021-10-28T08:24:25.148Z","comments":true,"path":"posts/20171023184559/","link":"","permalink":"https://www.laoliang.ink/posts/20171023184559/","excerpt":"","text":"查理芒格认为，现实世界的种种问题，很少是正好落在某一个学科的界限里面的，而往往是横跨多个学科的。但是我们传统的教育又是以学科和专业划界来培养人才。你是哪个专业的，你就只了解这个专业的知识，对别的学科知识一窍不通。一个心理学专业的人，一般不会懂经济学，而一个经济学专业的人，一般也不会懂心理学。但是当你在现实世界中要解决问题的时候，就发现这种狭窄的知识结构很成问题。 多元思维模型帮助你正确进行【价值投资】我们可能只是简单地认为，价值投资就是不投机，做长线，找有成长性的股票长期持有。道理很多人都懂，但是做不到。为什么？因为你不具备巴菲特和芒格这样的多元知识结构。说白点，就是没有像他们那样懂那么多。所以，价值投资的精华不在于长期持有这样的一种理念，而是你用什么样的知识来挑选出哪家公司是值得长期持有的，这才是特别显功力的地方。 我们应该掌握什么样的【普世智慧】按照芒格的说法，首先我们并不需要了解所有的学科，我们只要了解最重要的那几个学科就可以了，比如 数学、物理学、化学、工程学、生物学、心理学、经济学、统计学 等；其次，对于每一个学科，我们也只需要了解它其中最基本的那几个模型就可以了。掌握了这些基本模型，实际上就掌握了这些学科最主要的智慧。这些基本模型大概有一百个左右，其中最重要的模型，有 数学中的复利原理，排列组合原理，物理学中的临界点、倾覆力矩，化学中的自我催化模型，生物学中的现代达尔文模型，工程学中的冗余备份模型， 还有 心理学中的认知误判模型 等。 这些模型就组成了芒格所说的“多元思维模型”。这些模型正是我们每个人都应该掌握的“普世价值”。 以上内容摘自：【采铜-好书精读】——《穷查理宝典》：三个核心思维方法，吸收巴菲特搭档的人生智慧","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"SQL子查询总结：相关子查询与非相关子查询有什么区别","slug":"SQL子查询总结：相关子查询与非相关子查询有什么区别","date":"2016-11-26T02:31:27.000Z","updated":"2021-10-28T08:24:25.094Z","comments":true,"path":"posts/20161126103127/","link":"","permalink":"https://www.laoliang.ink/posts/20161126103127/","excerpt":"","text":"如果一个select语句能够返回单个值或者一列值，且该select语句嵌套在另一个SQL语句（例如select语句、insert语句、update语句或者delete语句）中，那么该select语句成为“子查询”（也叫内层查询），包含子查询的SQL语句称为“主查询”（也叫外层查询）。为了标记子查询与主查询之间的关系，通常将子查询写在小括号内。子查询一般用在主查询的where子句或having子句中，与比较运算符或者逻辑运算符一起构成where筛选条件或having筛选条件。子查询分为“相关子查询”（Dependent Subquery）与“非相关子查询”。 非相关子查询如果子查询返回单个值，则可以讲一个表达式的值与子查询的结果进行比较。例如，检索成绩比学生张三平均分高的所有学生及课程的信息， 可以使用下面的SQL语句， 执行结果如下图。 123456789mysql&gt; select class_name, student.student_no, student_name, course_name, score -&gt; from classes join student on student.class_no = classes.class_no -&gt; join choose on choose.student_no = student.student_no -&gt; join course on choose.course_no = course.course_no -&gt; where score &gt; ( -&gt; select avg(score) -&gt; from student, choose -&gt; where student.student_no = choose.student_no and student_name = &#x27;张三&#x27; -&gt; ); 说明该示例中的子查询是一个单独的select语句，可以不依赖主查询单独运行。这种不依靠主查询，能够独立运行的子查询称为“非相关子查询”。 执行过程 执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。 执行外部查询，并显示整个结果。 相关子查询下面的示例演示了相关子查询，代码第七行标记了两条子查询语句之间的区别（其他SQl代码完全相同），执行结果如下图。 123456789mysql&gt; select class_name, student.student_no, student_name, course_name, score -&gt; from classes join student on student.class_no = classes.class_no -&gt; join choose on choose.student_no = student.student_no -&gt; join course on choose.course_no = course.course_no -&gt; where score &gt; ( -&gt; select avg(score) -&gt; from choose -&gt; where student.student_no = choose.student_no and student_name = &#x27;张三&#x27; -&gt; ); 说明从执行结果可以看到，子查询可以仅仅使用自己定义的数据源，也可以“直接引用”主查询中的数据源，但两者意义完全不同。 如果子查询中仅仅使用了自己定义的数据源， 这种查询是非相关子查询。 非相关子查询是独立于外部查询的子查询， 子查询总共执行一次， 执行完毕后将值传递给主查询。 如果子查询中使用了主查询的数据源， 这种查询是相关子查询， 此时主查询的执行与相关子查询的执行相互依赖。 执行过程 从外层查询中取出一个元组，将元组相关列的值传递给内层查询。 执行内层查询，得到子查询操作的值。 外查询根据子查询返回的结果或结果集得到满足条件的行。 然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。 如何区分说了这么多，那我们该如何快速区分非相关子查询和相关子查询呢？ 最简单的办法的就是直接看子查询本身能否执行。比如执行上面的例子中的子查询： 123mysql&gt; select avg(score) -&gt; from choose -&gt; where student.student_no = choose.student_no and student_name = &#x27;张三&#x27;; 会报错：1054 - Unknown column &#39;student.student_no&#39; in &#39;where clause&#39;这样的查询语句构成的子查询便为相关子查询。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"理解Java中的向上转型","slug":"理解Java中的向上转型","date":"2016-11-25T12:57:23.000Z","updated":"2021-10-28T08:24:25.124Z","comments":true,"path":"posts/20161125205723/","link":"","permalink":"https://www.laoliang.ink/posts/20161125205723/","excerpt":"","text":"“为新的类提供方法”并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用“新类是现有类的一种类型”这句话加以概括。 这个描述并非只是一种解释继承的华丽的方式，这直接是由语言所支撑的。例如，假设有一个Instrument的代表乐器的基类和一个称谓Wind的导出类。由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。如果Instrument类具有一个play()方法，那么Wind乐器也将同样具备。这意味着我们可以准确地说Wind对象也是一种类型的Instrument。下面这个例子说明了编译器是怎样支持这一概念的： 1234567891011121314class Instrument &#123; public void play() &#123;&#125; static void tune(Instrument i) &#123; /* --- */ i.play(); &#125;&#125;public class Wind extends Instrument &#123; public static void main(String[] args) &#123; Wind flute = new Wind(); Instrument.tune(flute); // 向上转型 &#125;&#125; 在此例中，tune()方法可以接受Instrument引用，这实在太有趣了。但在Wind.main()中，传递给tune()方法的是一个Wind引用。鉴于Java对类型的检查十分严格，接受某种类型的方法同样可以接受另外一种类型就会显得很奇怪，除非你认识到Wind对象同样也是一种Instrument对象，而且也不存在任何tune()方法是可以通过Instrument来调用，同时又不存在于Wind之中。在tune()中，程序代码可以对Instrument和它所有的导出类起作用，这种将Wind引用转换为Instrument引用的动作，我们称之为向上转型。 为什么称为向上转型该术语的使用有其历史原因，并且是以传统的类继承图的绘制方法为基础的：将根置于页面的顶端，然后逐渐向下。（当然也可以以任何你认为有效的方法进行绘制。）于是，Wind.java的继承图就是： 由于导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型。由于向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。也就是说，导出类是基类的一个超集。它可能比基类含有更多的方法，但它必须至少具备基类中所含有的方法。在向上转型的过程中，类接口唯一可能发生的事情是丢失方法，而不是获取它们。这就是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。 再论组合与继承在面向对象编程中，生成和使用程序代码最有可能采用的方法就是直接将数据和方法包装进一个类中，并使用该类的对象。也可以运用组合技术使用现有类来开发新的类；而继承技术其实是不太常用的。因此尽管在教授OOP的过程中我们多次强调继承，但这并不意味着要尽可能使用它。相反应当慎用这一技术，其使用场合仅限于你确信使用该技术确实有效的情况。到底是该用组合还是用继承，一个最清晰的判断方法就是问一问自己是否需要从新类向基类进行向上转型。如果必须向上转型，则继承是必要的；但如果不需要，则应当好好考虑自己是否需要继承。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"Java赋值操作符注意事项及方法调用中的别名问题","slug":"Java赋值操作符注意事项及方法调用中的别名问题","date":"2016-11-18T08:16:22.000Z","updated":"2021-10-28T08:24:25.088Z","comments":true,"path":"posts/20161118161622/","link":"","permalink":"https://www.laoliang.ink/posts/20161118161622/","excerpt":"","text":"让我们先来回顾一下Java中的一些特性 ~~ 一切都是对象“如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界。”——Luduing Wittgerstein(1889-1951) 尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。 Java语言假设我们只是进行面向对象的程序设计。也就是说，在开始用Java进行设计之前，必须将思想转化到面向对象的世界中来。这个入门基本功，可以使你具备使用这样一门编程语言编程的能力，这种语言学习起来更简单，也比许多其他OOP语言更易用。 用引用操作对象每种编程语言都有自己的操作内存中元素的方式。有时候，程序员必须注意将要处理的数据是什么类型。你是直接操作元素， 还是用某种给予特殊语法的间接表示（例如C和C++里的指针）来操作对象？ 所有这一切在Java里都得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都看做对象，但操作的标识符实际上是对象的一个“引用”（reference）。 特例（基本类型）在程序设计中经常用到一系列类型，他们需要特殊对待。可以把它们想象成“基本”类型。之所以特殊对待，是因为new将对象存储在“堆”里，故用new创建一个对象——特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，Java采用与C和c++相同的方法。也就是说，不用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。 举例（有关赋值操作）在开始问题之前我们先来看这样一段代码 123456789101112131415161718192021class Tank &#123; int level;&#125;public class Assignment &#123; public static void main(String[] args) &#123; Tank t1 = new Tank(); Tank t2 = new Tank(); t1.level = 9; t2.level = 47; System.out.println(&quot;No.1: t1.level:&quot; + t1.level + &quot;, t2.level:&quot; + t2.level); t1 = t2; System.out.println(&quot;No.2: t1.level:&quot; + t1.level + &quot;, t2.level:&quot; + t2.level); t1.level = 27; System.out.println(&quot;No.3: t1.level:&quot; + t1.level + &quot;, t2.level:&quot; + t2.level); &#125;&#125; 运行结果 123No.1: t1.level:9, t2.level:47No.2: t1.level:47, t2.level:47No.3: t1.level:27, t2.level:27 为什么是这样一个结果呢？ 其实 Tank类非常简单，它的两个实例（t1和t2）是在main()里创建的。对每个Tank类对象的level域都赋予了一个不同的值，然后，将t2赋给t1， 接着又修改了t1。在许多编程语言中，我们可能会期望t1和t2总是相互独立的。但由于赋值操作的是一个对象的引用，所以修改t1的同时也改变了t2！这是由于t1和t2包含的是相同的引用，它们指向相同的对象。（原本t1包含的对对象的引用，是指向一个值为9的对象。在对t1赋值的时候，这个引用被覆盖了，也就是丢失了；而那个不再被引用的对象会由“垃圾回收器”自动清理。） 这种特殊的现象通常称作“别名现象”，是Java操作对象的一种基本方式。在这个例子中，如果想避免别名问题应该怎么办呢？可以这样写： 1t1.level &#x3D; t2.level; 这样便可以保持两个对象彼此独立，而不是将t1和t2绑定到相同的对象。但你很快就会意识到，直接操作对象内的域容易导致混乱，并且，违背了良好的面向对象程序设计的原则。这可不是一个小问题，所以从现在开始大家就应该留意，为对象赋值可能会产生意想不到的结果。 方法调用中的别名问题将一个对象传递给方法时，也会产生别名问题： 12345678910111213141516class Letter&#123; char c;&#125;public class PassObject &#123; static void f (Letter y)&#123; y.c = &#x27;z&#x27;; &#125; public static void main(String[] args)&#123; Letter x = new Letter(); x.c = &#x27;a&#x27;; System.out.println(&quot;1: x.c: &quot; + x.c); f(x); System.out.println(&quot;2: x.c: &quot; + x.c); &#125;&#125; 输出结果 121: x.c: a2: x.c: z 在很多编程语言中，方法f()似乎要在他的作用域内复制其参数Letter的一个副本；但实际上只是传递了一个引用。所以代码行 1y.c &#x3D; &#39;z&#39;; 实际改变的是f()之外的对象。 别名引起的问题及其解决方法是很复杂的话题，但是你现在就应该知道它的存在，并在使用中注意这个陷阱。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"实验——48小时丢手机之随手记","slug":"实验——48小时丢手机之随手记","date":"2016-10-08T00:23:13.000Z","updated":"2021-10-28T08:24:25.063Z","comments":true,"path":"posts/20161008082313/","link":"","permalink":"https://www.laoliang.ink/posts/20161008082313/","excerpt":"","text":"受一篇文章启发，我也尝试进行了这样一场“48小时彻底离开手机和网络”的实验。下面是我在这个过程中随手记下的感受。 在这48小时中，我主要做了些： 阅读完王小波的一本杂文集——《我的精神家园》 阅读完图灵系列期刊——码农.第2期——Javascript 阅读了《Thinging in Java》的第一章 阅读了《Pro Git》的第七章 完成毛概的小作业+复习了微机原理的功课 市中逛街购买生活用品+休闲 洗衣洗鞋以及整理房间…… ☟ 下面是在这过程中的一些随手记 为了模拟常规状态下的真实体验，并未对两天内做具体的安排，具体做什么，看心情好了。 为了增加仪式感，特地在12:00整在社交网站发了一条实验启动的状态，然后关闭手机，切断了一切连接网络的设备。 让我们开始吧！ 为了有一个轻松地开始，我选择干的第一件事是阅读，在自己的待读书目里选出一本最期待的开始了一天。 图书馆坐得累了， 我想起了手机，平日总会赶着休息的空闲刷一刷朋友圈，看看朋友们的动态，这会儿我也犯了这个痒，心里总在焦虑的想，这会儿朋友中又发生了哪些事儿，但我身上没有手机，更不能上网。 我蛮想看看昨天社交平台上的状态有了哪些回复…… 不能上网，只能听iPad里缓存过的歌，平时放松放首歌，歌声基本只是背景乐，自己一定忙着别的，比如刷手机，而这会儿突感无事可做，便听着歌看着歌词，才感歌词好美，平日并未在意的小调，也特别生动。 坐公交去市区，下意识地想拿出手机摆弄，但却发现并没有手机，只好看着满车人民均低着头沉浸在自己的一片天地，只有我独自欣赏窗外闪过的美景，这西南小城，并不繁华但却不落俗气，节奏适宜，的确是宜居的很、巴适得板！生活在一座城，便恋上一座城，明年正也打算拉父母转过来一同生活，共享这安逸。 听到一首赵雷的《人家》，好好听，想搜搜吉他谱看难不，但我不能上网啊！啊哈哈…… 早晨等热水和厕所的这一小段空闲，我翻开了心血来潮买回来的大部头《Thinking in Java》，因为最近忙于琐事，一直未读，今早将目录以前的所有介绍性的章节读了一遍，这是一本可以令人心潮澎湃的书，平日里，这样短小的零碎时间，多数都以手机里的快餐资讯填充了，而现在发现，没有手机和网络也同样可以获得那种快感，而且这种快感更加真实、亲切。 也并非在整个过程中不使用智能设备，当然，手机我是没敢打开，只用iPad听过歌，看过吉他谱和课件，但这所有的操作都是在离线状态下，如果联网，我可能会频繁地切换APP，有人说那些电子设备就不是用来学习的，在联网的情况下的确是这样。 朋友的手机响了，打断了思绪，想起平日学习过程中，被自己手机消息打断的情形，这并不是说自己多么沉迷学习厌恶被打断，而是自己对这种干扰又爱又恨，因为收到消息可以把自己从苦闷的学习中暂时解脱出来而爱，又因为让自己心意上过不去而恨，并且平日更多时候自己还会主动去查看手机是否有新消息。今后学习过程中，将手机关机是个不错的想法。 有时会为关闭手机切断所有网络连接而感到欣喜，我会清晰地知道，在这个时间段内，绝对不会有人来打扰我。 我是想查个单词的，没有手机和网络确实这些需求变得不方便，于是我搬出了吃灰许久的牛津双解，虽然笨拙，但却感到蛮有趣，别有一番风味。 很需要下载一首歌曲，冒险（之所以说是冒险，是因为担心自己控制不住而网上冲浪）打开了iPad的WiFi连接，先开了勿扰模式的，但还是收到了QQ消息的提醒，还是自己心仪女孩发来的，丫的！太有挑战了，我强忍着好奇和期待清空了通知，下载好歌曲之后，关掉了WiFi连接，真好奇收到的是什么，哈哈，我的心绞痛，心中纠结的原因不是因为不能回复消息的负罪感，而是自身期待查看消息的好奇心不能满足。 一想到今晚12点之后就可以重新接入互联网就感到好兴奋，而Now，继续享受这最后一段自在的时光吧！ 书是看不进去了，于是我选择了去吃饭，平时遇到这样坐不住椅子的情况时，多数情况都是用上网冲浪的方式来填充，因为这个原因而得出“没有网络是件好事儿”的结论确实有些牵强，但不可否认的是：在这即将结束的48小时实验时间里、在我并没有给自己提前指定任务清单并试图调用更多自控力去执行清单任务的情况下，确实比往日做了更多有价值或有意义的事情，或者说明显地减少了毫无意义甚至颓废的时间开销。 现在离实验结束还有2小时10分钟，从我内心饱满的状态和充实的感觉以及并未发生的曾预想中的强烈不适反应来看，我得出了下面的结论，或是说实验心得： 在今天，网络和智能设备已经成为我们工作、学习和生活不可分割的一部分，但适时、有计划地丢掉智能设备，断开自身与网络的连接，可以让我们生活得更好！ 以上就是在这48小时实验当中，随手记下的当时时刻的小心情，仅作分享，同时非常感谢陪伴自己一同践行此次“48小时丢手机”实验的美美哒师妹，没有她的提醒，可能并不会真正实践当初只是在脑海里设想过的这个想法。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"Markdown简明手册","slug":"Markdown简明手册","date":"2016-09-10T03:46:17.000Z","updated":"2021-10-28T08:24:25.054Z","comments":true,"path":"posts/20160910114617/","link":"","permalink":"https://www.laoliang.ink/posts/20160910114617/","excerpt":"","text":"Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 John Gruber 在 2004 年创造了 Markdown 语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML (或是HTML)”。其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记 (像是 RTF 与 HTML)。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：setext、Texile、reStructuredText。 许多网站都使用 Markdown 或是其变种，例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 与 SourceForge 让用户更利于讨论。 Markdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号&lt;和&amp;号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器。 Markdown也已经被其他人用Perl和别的编程语言重新实现，其中一个Perl模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。 引自维基百科 Markdown 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 *斜体*，这是 *粗体*。 效果：这是 斜体，这是 粗体。 2. 分级标题使用 # 表示一级标题，使用 ## 表示二级标题。 示例： # 这是一个一级标题 ## 这是一个二级标题 ### 这是一个三级标题 效果：这是一个一级标题这是一个二级标题这是一个三级标题3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 [本人博客](https://www.laoliang.ink) 的链接。 效果：这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： - 无序列表项 1- 无序列表项 2- 无序列表项 3 效果： 无序列表项 1 无序列表项 2 无序列表项 3 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 效果： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： &gt; 野火烧不尽，春风吹又生。 效果： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 `html`。 效果：让我们聊聊 html。 8. 代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： ```$ sudo apt-get install vim-gnome``` 非代码效果：1$ sudo apt-get install vim-gnome Python 示例： ```pythonimport sys for s in sys.stdin: a = [int(i) for i in s.split()] print (a[0] + a[1])``` Python 效果：12345import sysfor s in sys.stdin: a = [int(i) for i in s.split()] print (a[0] + a[1]) JavaScript 示例： ``` javascriptfunction fib(n) { var a = 1, b = 1; var tmp; while (–n &gt;= 0) { tmp = a; a += b; b = tmp; } return a;} document.write(fib(10));``` JavaScript 效果：123456789101112function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： ![我的头像](https://avatars.githubusercontent.com/u/23415234?s=460&amp;u=246c673b3fe369d7146089bce615857f0aaf09a6&amp;v=4) 效果：","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"Git常用命令笔记","slug":"Git常用命令笔记","date":"2016-08-04T05:10:48.000Z","updated":"2021-10-28T08:24:25.027Z","comments":true,"path":"posts/20160804131048/","link":"","permalink":"https://www.laoliang.ink/posts/20160804131048/","excerpt":"","text":"注：本文引自图灵社区系列杂志《码农·进击的Java（总第16期）》，部分有删减，仅用于个人备忘笔记及交流使用 作者/颜海镜 90后一枚，活跃在各个技术社区，常以歪脖无脸男作为头像，专注于 Web 前端开发已有三个年头，关注 HTML/CSS/JavaScript 等技术，目前就职于北京金山软件，坚信 Web 赢在未来。热爱思考，热爱开源分享，常翻译些外文博客，此外还爱好读书，羽毛球，乒乓球，相声，铁杆钢丝，当然非常热爱写代码了，http://yanhaijing.com/ 是我的个人博客。 起初的时候我使用 github for windows 这个客户端，再切换到多分支的时候被自动转换换行符坑的不浅，后来阅读了 《git详解》系列文章，对 Git 的了解深入了一步，这篇文章记录个人常用的一些命令，和记不住大一些命令。 安装在 Windows 上安装 Git 同样轻松，我们可以到 https://git-scm.com/downloads 下载对应操作系统的安装包。 安装完成之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。 配置配置账号信息123456git config --global user.name yournamegit config --global user.email youname@example.comgit config --list #查看配置的信息git help config #获取帮助信息 配置自动换行（自动转换坑太大）1git config --global core.autocrlf input #提交到 git 是自动将换行符转换为lf 配置密钥123ssh-keygen -t rsa -C yourname@example.com #生成密钥ssh -T git@github.com #测试是否成功 新建仓库123456git init #初始化git status #获取状态git add file #.或*代表全部添加git commit -m &quot;message&quot; #此处注意乱码git remote add origin git@github.com:yourname&#x2F;test.git #添加源git push -u origin master #push同时设置默认跟踪分支 从现有仓库克隆12git clone git:&#x2F;&#x2F;github.com&#x2F;yourname&#x2F;data.gitgit clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;grit.git mypro #克隆到自定义文件夹 本地12345678910111213141516171819git add * #跟踪新文件rm * &amp; git rm * #移除文件git rm -f * #移除文件git rm --cached * #取消跟踪git mv file_from file_to #重命名跟踪文件git log #查看提交记录git commit #提交更新记录git commit -m &quot;message&quot;git commit -a #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交git commit -amend #修改最后一次提交git reset HEAD * #取消已经暂存的文件git checkout -- file #取消对文件的修改（从暂存区去除file）git checkout branch|tag|commit -- file_name #从仓库取出 file 覆盖当前分支git checkout -- . #从暂存区取出文件覆盖工作区 分支1234567891011121314151617git branch #列出本地分支git branch -r #列出远端分支git branch -a #列出所有分支git branch -v #查看各个分支最后一个提交对象的信息git branch --merge #查看已经合并到当前分支的分支git branch --no-merge #查看未合并到当前分支的分支git branch test #新建 test 分支git checkout test #切换到 test 分支git checkout -b test #新建并切换到 test 分支git checkout -b test dev #基于 dev 新建 test 分支，并切换git branch -d test #删除 test 分支git branch -D test #强制删除 test 分支git merge test #将 test 分支合并到当前分支git rebase master #将 master 分支智商超前的提交，变基到当前分支 远端12345678git fetch origin_name branch_name #拉取远端上指定分支git merge origin_name branch_name #合并远端上指定分支git push origin_name branch_name #推送到远端上指定分支git push origin_name local_branch:server_branch #推送到远端上指定分支git checkout -b test origin&#x2F;dev #基于远端 dev 新建 test 分支git push origin :server #删除远端分支 源Git 是一个分布式代码管理工具，所以可以支持多个仓库，在 Git 里，服务器上的仓库在本地称之为 remote。 个人开发时，多源用的可能不多，但多源其实非常有用。 12345678910git remote add origin1 git@github.com&#x2F;yourname&#x2F;data.gitgit remote #显示全部源git remote -v #显示全部源+详细信息git remote rename origin1 origin2 #重命名git remote rm origin1 #删除git remote show origin1 #查看指定源的全部信息 标签当开发到一定阶段时，给程序打标签是非常棒的习惯。 1234567891011git tag #列出现有标签git tag v0.1 #新建标签git tag -a v0.1 -m &quot;My version 1.4&quot; #新建带注释标签git checkout tag_name #切换到标签git push origin v1.5 #推送分支到源上git push origin --tags #一次性推送所有分支git tag -d v0.1 #删除标签git push origin :refs&#x2F;tags&#x2F;v0.1 #删除远程标签 总结啊哈！终于总结完了，以后不会的时候，再也不用到处去找了。 其实还有两个最有用的命令未提到。 12git help * #获取命令的帮助信息git status #获取当前的状态，非常有用，因为 Git 会提示接下来的能做的事情","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"Git快速入门（三）","slug":"Git快速入门（三）","date":"2016-08-03T05:10:48.000Z","updated":"2021-10-28T08:24:25.039Z","comments":true,"path":"posts/20160803131048/","link":"","permalink":"https://www.laoliang.ink/posts/20160803131048/","excerpt":"","text":"现在的你对于 Git 应该完全不会感到陌生了吧，通过之前两节内容的学习，你已经掌握了很多 Git 中常用的命令，像提交代码这种简单的操作相信肯定是难不倒你的。 那么打开 Git Bash，在指定目录创建项目的跟目录，然后执行提交操作： 123git initgit add .git commit -m &quot;First Commit.&quot; 这样就将准备工作完成了，下面就让我们开始学习关于 Git 的高级用法。 分支的用法分支是版本控制工具中比较高级且比较重要的一概念，它主要的作用就是在现有代码的基础上开辟一个分叉口，使得代码可以在主干线和分支线上同时进行开发，且相互之间不会影响。 你也许会有疑惑，为什么需要建立分支呢？只在主干线上进行开发不是挺好的吗？没错，通常情况下，只在主干线上进行开发是完全没有问题的， 不过一旦涉及版本的情况，如果不建立分支的话，你就会非常的头疼。 举个例子吧比如说你们公司研发了一款不错的软件，最近刚刚完成，并推出了1.0版本。但是领导是不会让你们闲着的，马上提出了新的需求，让你们投入到了1.1版本的开发工作当中。过了几个星期，1.1版本的功能已经完成了一半，但是这个时候用户反馈，之前上线的1.0版本发现了几个重大的bug，严重影响软件的正常的正常使用。领导也相当重视这个问题，要求你们立刻修复这些bug，并重新发布1.0版本，但这个时候你就非常为难了，你会发现根本没法儿去修复这些bug。因为现在1.1版本已经开发到一半了，如果在现有的代码的基础上修复这些bug，那么更新的1.0版本将会带有一半1.1版本的功能！ 进退两难了是不是？但是如果你使用了分支的话，就完全不会存在这个让人头疼的问题。你只需要在发布1.0版本的时候建立一个分支，然后在主线上继续开发1.1版本的功能。当1.0版本上发现任何bug的时候，就在分支上进行修改，然后发布新的1.0版本，并记得将修改后的代码合并到主干线上。这样的话，不仅可以轻松解决掉1.0版本存在的bug，而且保证了主干线上的代码也已经修复了这些bug，当1.1版本发布的时候就不会有同样的bug存在了。 说了这么多，相信你也已经意识到分支的重要性了，那么我们马上来学习一下如何在Git中操作分支吧。 分支的英文名是branch，如果想要查看当前的版本库当中有哪些分支，可以使用git branch这个命令。 创建一个分支： 1git branch version1.0 这样就创建了一个名为version1.0的分支，我们可以再次输入git branch这个命令来检查一下。 切换分支： 1git checkout version1.0 这样我们就可以把代码成功切换到version1.0这个分支上了。 需要注意的是，在version1.0分支上修改并提交的代码将不会影响到master分支。同样的道理，在master分支上修改并提交的代码也不会影响到version1.0分支。因此如果我们在version1.0分支上修复了一个bug，在master分支上这个bug仍然是存在的。这时将修改的代码一行行赋值到master分支显然不是一种聪明的做法，最好的办法就是使用merge命令来完成合并操作： 12git checkout mastergit merge version1.0 仅仅这样简单的两行命令，就可以把在version1.0分支上修改并提交的内容合并到master分支上了。当然，在合并分支的时候还有可能出现代码冲突的情况，这个时候你就需要静下心来慢慢找出并解决这些冲突，Git在这里就无法帮助你了。 最后，当我们不再需要version1.0这个分支的时候，可以使用如下命令将这个分支删除掉： 1git branch -D version1.0 与远程版本库协作可以这样说，如果你是一个人在开发，那么使用版本控制工具救援预案无法发挥出它真正强大的功能。没错，所有版本控制工具最重要的一个特点就是可以使用它来进行团队合作开发。每个人的电脑上都会有一份代码，当团队的某个成员在自己的电脑上编写完成了某个功能之后，就将代码提交到服务器，其他的成员只需要将服务器上的代码同步到本地，就能保证整个团队所有人的代码都相同。这样的话，每个团队成员就可以各司其职，大家共同来完成一个较为庞大的项目。 那么如何使用Git来进行团队合作开发呢？这就需要有一个远程的版本库，团队的每个成员都从这个版本库中获取到最原始代码，然后各自进行开发，并且以后每次提交的代码都同步到远程版本库上就可以了。另外，团队中的每个成员最好都要养成经常从版本库中获取最新代码的习惯，不然的话，大家的代码就很有可能经常出现冲突。 比如说现在有一个远程版本库的Git地址是https://github.com/example/test.git，就可以使用如下的命令将代码下载到本地： 1git clone https:&#x2F;&#x2F;github.com&#x2F;example&#x2F;test.git 之后你在这份代码的基础上进行了一些修改和提交，那么怎样才能把本地修改的内容同步到远程版本库上呢？这就需要借助push命令来完成了，用法如下： 1git push origin master 其中origin部分指定的是远程版本库的Git地址，master部分指定的是同步到哪一个分支上，上述命令就完成了将本地代码同步到https://github.com/example/test.git这个版本库的master分支上的功能。 知道了将本地的修改同步到远程版本库上的方法，接下来我们看一下如何将远程版本库上的修改同步到本地。Git提供了两种命令来完成此功能，分别是fetch和pull，fetch的语法规则和push是差不多的，如下： 1git fetch origin master 执行这个命令后，就会将远程本本库上的代码同步到本地，不过同步下来的代码并不会合并到任何分支上去，而是会存放在一个origin/master分支上，这是我们就可以通过diff命令来查看远程版本库上到底修改了哪些东西： 1git diff origin&#x2F;master 之后再调用merge命令将origin/master分支上的修改合并到主分支上即可，如下所示： 1git merge origin&#x2F;master 而pull命令则是相当于将fetch和merge这两个命令放在一起执行了，它可以从远程版本库上获取最新的代码并合并到本地，用法如下： 1git pull origin master 注：Git快速入门 系列文章大部分内容整理自“郭霖”大神的《第一行代码》内容，记录在此仅做备忘笔记及交流使用，切勿用于商业用途","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"Git快速入门（二）","slug":"Git快速入门（二）","date":"2016-08-02T05:10:48.000Z","updated":"2021-10-28T08:24:25.044Z","comments":true,"path":"posts/20160802131048/","link":"","permalink":"https://www.laoliang.ink/posts/20160802131048/","excerpt":"","text":"上一次我们介绍了 Git 的环境配置和创建本地版本库本节我们一起来看 Git 的更多使用技巧。 忽略文件为什么要忽略文件呢，版本控制工具的初衷之一就是为了能够更多人更好地合作，方便多人维护同一份代码，那么对于常见的程序源代码，我们往往并不是需要把项目目录下所有的文件都加入到版本控制当中，例如，项目构建过程中生成的文件、本地IDE配置文件等，那么如何才能实现这样的效果呢？ Git 提供了一种可配型很强的机制来允许用户将指定的文件或目录排除在版本控制之外，它会检查代码仓库的目录下是否存在一个名为 .gitignore 的文件，如果存在的话，就去一行行读取这个文件中的内容，并把每一行指定的文件或目录排除在版本控制之外。注意，.gitignore 中指定的文件或目录是可以使用 * 通配符的。 下面是 GitHub 上面给出的常见工程项目的 .gitignore 模板，仅供参考，实际项目中还要根据自己团队间的具体需求进行增改： 链接：A collection of useful .gitignore templates 查看修改内容我们知道可以通过 git status，随时查看版本库工作区当前的文件状态，那么该如何看到更改的内容呢？这就需要借助 diff 命令了，用法如下： 1git diff 这样可以查看到所有文件的更改内容，如果你只想查看某一个文件的更改内容，可以使用如下命令： 1git diff filename 撤销未提交的更改有时候我们的代码可能会写的过于草率，以至于原本正常的功能，结果反倒被我们改出了问题。遇到这种情况时也不用着急，因为只要代码还未提交，所有修改的内容都是可以撤销的。 比如，继上次提交以后，我们在工作区对文件 a.cpp 做了修改，现在如果想要撤销这个修改就可以使用 checkout 命令，用法如下所示： 1git checkout a.cpp 执行了这个命令之后，我们对 a.cpp 这个文件所做的一切修改就应该都被撤销了。我们可以通过 git status 查看该文件的状态。 不过这种撤销方式只适用于那些还没有执行过 add 命令的文件，如果某个文件已经被添加过了，这种方式就无法撤销其更改的内容。 此时我们应该先对其取消添加，然后才可以撤回提交。取消添加用的是 reset 命令，用法如下所示： 1git reset HEAD a.cpp 然后再运行一遍 git status 命令，我们就会发现 a.cpp 这个文件重新变回了为添加状态，此时就可以使用 checkout 命令来将修改的内容进行撤销了。 查看提交记录当项目开发几个月之后，我们可能已经执行过上百次提交操作了，这时，我们可以使用 log 命令查看历史提交信息，用法如下所示： 1git log 如果只想看其中一条记录，可以在命令中指定该记录的 id，并加上 -1 参数表示我们只想看到一行记录，如下所示： 1git log 1fa38 -1 其中提交记录的 id 我们只需要键入开头几个字母就可以了，因为 Git 会帮我们匹配是哪一条提交记录，如果 Git 不能唯一标示，它会提示你。 而如果想查看这条提交记录具体修改了什么内容，可以在命令中加入 -p 参数，命令如下： 1git log 1fa38 -1 -p","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]},{"title":"Git快速入门（一）","slug":"Git快速入门（一）","date":"2016-08-01T05:10:48.000Z","updated":"2021-10-28T08:24:25.034Z","comments":true,"path":"posts/20160801131048/","link":"","permalink":"https://www.laoliang.ink/posts/20160801131048/","excerpt":"","text":"为什么要写此系列教程我是一个有着严重拖延的人，对于新鲜事物很感兴趣，但是执行力很差。编辑此篇教程既是对自己学习新工具的总结，更是对自己办事执行力上的考验。 好，下面我们进入正题。 关于版本控制什么是 “版本控制”？我为什么要关心它呢？ 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 在本书所展示的例子中，我们对保存着软件源代码的文件作版本控制，但实际上，你可以对任何类型的文件进行版本控制。 如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。 ——摘自《Pro Git 2nd Edition (2014)》 本篇教程只是带领大家快速了解 Git，并掌握 Git 的基础用法。更多规范详细教程请参考：官方文档 Pro Git （可切换中文版哦） Git的安装及环境配置Linux下的安装由于 Git 和 Linux 操作系统是同一个作者，因此 Git 在 Linux 上的安装是最简单方便的。比如你用的是 Ubuntu 系统，只需要打开 shell 界面，并输入： 1sudo apt-get install git 按下回车后输入密码，即可完成 Git 的安装。 如果是老一点的 Linux 系统，要把命令改为： 1sudo apt-get install git-core 因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 Windows下的安装虽然 Windows 常被程序员诟病是最烂的开发平台，不过我相信在中国，你最有可能使用的还是 Windows 操作系统。不同于 Linux，Windows 上无法通过一行命令就完成安装，我们需要把 Git 的安装包到 官网下载 下来，之后一直点击“下一步”就可以完成安装了。 Mac下的安装哈哈，穷小子买不起苹果电脑，没办法给大家演示，不过安装方法都是大同小异，命令行、第三方工具、官网直接下载…… 创建版本库初次运行Git前的配置如果你使用的是 Linux 系统，就先打开 shell 界面，如果用的是 Windows 系统，就从开始里找到 Git Bash 并打开。 首先应该配置一下你的身份，这样在提交代码的时候 Git 就可以知道是谁提交的了，命令如下所示： 12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot; 配置完成后你还可以使用同样的命令查看是否配置成功，只需要将最后的名字和邮箱地址去掉即可，向下面这样： 12git config --global user.namegit config --global user.email 以上的基础信息配置，作用域是针对全局的（global），也就是说，在当前机器下，默认创建的所有版本仓库都会应用此配置信息，如果想要单独针对某一个仓库设定不同的配置信息，可以针对指定仓库单独配置。 初始化仓库然后我们就可以开始常见代码仓库了，仓库（Repository）适用于保存版本管理所需信息的地方，所有本地提交的代码都会被提交代码仓库中，如果有需要的还可以再推送到远程仓库中。 首先移动到想要创建仓库的文件夹下： 1cd .&#x2F;YourRepositoryFolder 初始化仓库： 1git init 这时，在你保存 Git 仓库的文件夹下就会生成一个隐藏的 .git 文件夹，这个文件夹就是用来记录本地所有的 Git 操作的，可以通过 ls -al 查看一下。 如果你想要删除本地仓库，只需要删除这个文件夹就行了。 提交本地代码代码仓库简历完之后就可以提交代码了，其实提交代码也非常简单，只需要使用 add 和 commit 命令就可以了，add 命令用于把想要提交的代码先添加进来（设置 追踪），而 commit 则是真正的去执行提交操作。 首先我们在刚刚的文件夹下创建两个新文件 one.txt 和 two.txt，我们可以通过以下命令将其添加到进来： 12git add one.txtgit add two.txt 也可以一次性添加所有文件： 1git add . 期间，我们可以通过以下命令来随时查看工作区状态： 1git status 接下来我们可以来提交一下，输入如下命令： 1git commit -m &quot;First commit&quot; 注意，在 commit 命令后面，我们一定要通过 -m 参数来加上提交的描述信息，没有描述信息的提交被认为是不合法的。这样所有的代码就已经成功提交了！","categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]}],"categories":[{"name":"未分类","slug":"未分类","permalink":"https://www.laoliang.ink/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"无标签","slug":"无标签","permalink":"https://www.laoliang.ink/tags/%E6%97%A0%E6%A0%87%E7%AD%BE/"}]}